<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Slicer 2: ORNL::CirclePack Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Slicer 2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_o_r_n_l_1_1_circle_pack.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_o_r_n_l_1_1_circle_pack-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ORNL::CirclePack Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="circlepack_8h_source.html">circlepack.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae7520b4b329ef92dc9229557e277dc1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#ae7520b4b329ef92dc9229557e277dc1e">CirclePack</a> ()</td></tr>
<tr class="separator:ae7520b4b329ef92dc9229557e277dc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2390e74369a7de0dac45c9184c4d72c4"><td class="memItemLeft" align="right" valign="top">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a2390e74369a7de0dac45c9184c4d72c4">generateUniformSquareGrid</a> (int64_t edge_length, int64_t x_offset, int64_t y_offset, int64_t rows, int64_t columns, bool include_secondary=true)</td></tr>
<tr class="memdesc:a2390e74369a7de0dac45c9184c4d72c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">generateUniformSquareGrid, generateUniformHexGrid These functions take in as parameters the x and y coordinates of the first vertex in the graph, the length of the edges in the graph, and the number of rows and columns in the graph. For the square version, the output is a uniform square grid with secondary vertices included by default in the interstices. Optionally, passing in false to the “include_secondary” parameter will leave these out. For the hex version, the output is a uniform hexagonal grid composed of equilateral triangles. Optionally, passing in true to the “set_secondary” parameter will set specific vertices in the hex grid as secondary vertices so that all secondary vertices are separated from neighboring secondary vertices by exactly one line of vertices.  <br /></td></tr>
<tr class="separator:a2390e74369a7de0dac45c9184c4d72c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e021a67368ef67cb5660574197fd07"><td class="memItemLeft" align="right" valign="top">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#af4e021a67368ef67cb5660574197fd07">generateUniformHexGrid</a> (int64_t edge_length, int64_t x_offset, int64_t y_offset, int64_t rows, int64_t columns, bool set_secondary=false)</td></tr>
<tr class="separator:af4e021a67368ef67cb5660574197fd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaab035d96c013619dae08eb42586902"><td class="memItemLeft" align="right" valign="top">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#abaab035d96c013619dae08eb42586902">generateContainedSquareGrid</a> (<a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons, int64_t edge_length, bool include_secondary=true)</td></tr>
<tr class="memdesc:abaab035d96c013619dae08eb42586902"><td class="mdescLeft">&#160;</td><td class="mdescRight">generateContainedSquareGrid, generateContainedHexGrid These functions generate square and hex grids, respectively, within a boundary specified by the polygons parameter with grid edges of the specified length. The overloaded versions provide the option to directly specify the offsets, rows, and columns for generating the initial grids of which a subset contained within the boundary is returned. The simple versions guarantee that the space within the boundary will be filled as fully as possible, while the overloaded versions do not guarantee this since the user will be directly controlling the generation of the initial grids. Also, in the <a class="el" href="class_o_r_n_l_1_1_circle_pack.html">CirclePack</a> object there is a “boundary_mode” field with possible values TANGENT and CENTER. By default, when a <a class="el" href="class_o_r_n_l_1_1_circle_pack.html">CirclePack</a> object is created, the “boundary_mode” field is set to TANGENT. These modes will be explained later in the section “Fitting Graphs to Boundaries”, but if the “boundary_mode” is set to CENTER, then extra vertices that touch inside of the boundaries (but have centers outside) are also included in the returned graph. The optional parameters “include_secondary” and “set_secondary” are explained in section “Uniform Graphs”.  <br /></td></tr>
<tr class="separator:abaab035d96c013619dae08eb42586902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0042f2c766976b240bfe28b027ab687c"><td class="memItemLeft" align="right" valign="top">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a0042f2c766976b240bfe28b027ab687c">generateContainedSquareGrid</a> (<a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons, int64_t edge_length, int64_t x_offset, int64_t y_offset, int64_t rows, int64_t columns, bool include_secondary=true)</td></tr>
<tr class="separator:a0042f2c766976b240bfe28b027ab687c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45509d6a95b4b620eead9b0886ae99d4"><td class="memItemLeft" align="right" valign="top">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a45509d6a95b4b620eead9b0886ae99d4">generateContainedHexGrid</a> (<a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons, int64_t edge_length, bool set_secondary=false)</td></tr>
<tr class="separator:a45509d6a95b4b620eead9b0886ae99d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82ffb3e580029ec0706c9ec9104c466"><td class="memItemLeft" align="right" valign="top">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#af82ffb3e580029ec0706c9ec9104c466">generateContainedHexGrid</a> (<a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons, int64_t edge_length, int64_t x_offset, int64_t y_offset, int64_t rows, int64_t columns, bool set_secondary=false)</td></tr>
<tr class="separator:af82ffb3e580029ec0706c9ec9104c466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0965c5bd1f18e43a1c20972d3fc7a661"><td class="memItemLeft" align="right" valign="top">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a0965c5bd1f18e43a1c20972d3fc7a661">generateEnvelopingSquareGrid</a> (<a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons, int64_t edge_length, int64_t margin, bool include_secondary=true)</td></tr>
<tr class="memdesc:a0965c5bd1f18e43a1c20972d3fc7a661"><td class="mdescLeft">&#160;</td><td class="mdescRight">generateEnvelopingSquareGrid, generateEnvelopingHexGrid These functions generate square and hex grids, respectively, that envelop the boundary specified by the polygons parameter with grid edges of the specified length. The size of the envelop is determined by the margin parameter which specifies the desired distance between the outermost vertices and the boundary. The optional parameters “include_secondary” and “set_secondary” are explained in section “Uniform Graphs”. These functions tend to be the most useful when refinements are desired. This is because refinements do not guarantee that the overall shape of the graph will remain the same after packing, but if only internal vertices that are relatively at a distance from the boundary are refined then the overall shape tends to remain very similar. However, we don’t want a huge margin either because that slows down the packing process. Thus when using these methods, a good margin tends to be around 2-3 times the edge length.  <br /></td></tr>
<tr class="separator:a0965c5bd1f18e43a1c20972d3fc7a661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17d9bcf0f231fe0e7b5f0b0c665ae55"><td class="memItemLeft" align="right" valign="top">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#af17d9bcf0f231fe0e7b5f0b0c665ae55">generateEnvelopingHexGrid</a> (<a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons, int64_t edge_length, int64_t margin, bool set_secondary=false)</td></tr>
<tr class="separator:af17d9bcf0f231fe0e7b5f0b0c665ae55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41792410b9c25cd19c96fd25eac551f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a41792410b9c25cd19c96fd25eac551f4">fitGraphToBoundary</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, <a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons, bool pin=true)</td></tr>
<tr class="memdesc:a41792410b9c25cd19c96fd25eac551f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">fitGraphToBoundary This function adjusts the locations and radii of the vertices in the given graph to minimize circle overlaps while also maximizing the conformity of the overall graph shape to the given boundary specified by the polygons. Usage notes: This function tends to work best with graphs that already fit inside the boundary such as those generated by the contained graph generators. This function usually does not work well with graphs that have large hollow spaces internally which are typical of many dual graphs.  <br /></td></tr>
<tr class="separator:a41792410b9c25cd19c96fd25eac551f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4deb2ca04f550169915ca615acd05e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a7d4deb2ca04f550169915ca615acd05e">fitGraphToBoundary</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, <a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons, int64_t min_radius, int64_t max_radius, bool pin=true)</td></tr>
<tr class="separator:a7d4deb2ca04f550169915ca615acd05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c50fc4c50aa5106e03cddd7f65bb543"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a0c50fc4c50aa5106e03cddd7f65bb543">FieldPackGraph</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, <a class="el" href="class_o_r_n_l_1_1_field.html">Field</a> *field, int64_t min_radius, int64_t max_radius, int64_t radius_delta)</td></tr>
<tr class="memdesc:a0c50fc4c50aa5106e03cddd7f65bb543"><td class="mdescLeft">&#160;</td><td class="mdescRight">FieldPackGraph ??  <br /></td></tr>
<tr class="separator:a0c50fc4c50aa5106e03cddd7f65bb543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04581a62e9e6f0572bfd0e67b9473f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#ac04581a62e9e6f0572bfd0e67b9473f0">pruneGraph</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, int64_t min_neighbors=<a class="el" href="namespace_o_r_n_l.html#a32447aecab629191e3ca4c4ca2f3e08a">DEFAULT_MIN_NEIGHBORS</a>, int64_t min_neighbors_secondary=<a class="el" href="namespace_o_r_n_l.html#a507f4ea7306a16188f8341d3615789a2">DEFAULT_MIN_NEIGHBORS_FOR_SECONDARY</a>)</td></tr>
<tr class="memdesc:ac04581a62e9e6f0572bfd0e67b9473f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">pruneGraph This function continuously removes all isolated vertices, vertices with less than the specified minimum number of neighbors, and secondary vertices with less than the specified minimum number of neighbors until no more vertices are valid for removal. The default numbers are 2 and 3 for regular vertices and secondary vertices, respectively.  <br /></td></tr>
<tr class="separator:ac04581a62e9e6f0572bfd0e67b9473f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d617ca1e38e24c56a74701717e60abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a0d617ca1e38e24c56a74701717e60abb">removeInternalSecondary</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph)</td></tr>
<tr class="memdesc:a0d617ca1e38e24c56a74701717e60abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">removeInternalSecondary This function removes all non-boundary vertices that are marked as secondary from the given graph.  <br /></td></tr>
<tr class="separator:a0d617ca1e38e24c56a74701717e60abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24335fc5f7a34005a60bef70e4b7f78d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a24335fc5f7a34005a60bef70e4b7f78d">removeVertexSelection</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt; removal_set)</td></tr>
<tr class="memdesc:a24335fc5f7a34005a60bef70e4b7f78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">removeVertexSelection This function removes from the graph the subset of its vertices given in the removal set. This function is actually extremely versatile as it can remove any selection of vertices from the graph. Also this function maintains a proper DCEL graph, which is a very important property for a large portion of the code in <a class="el" href="class_o_r_n_l_1_1_circle_pack.html">CirclePack</a>.  <br /></td></tr>
<tr class="separator:a24335fc5f7a34005a60bef70e4b7f78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9e95fba88184df22556ed4a6895871"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a4f9e95fba88184df22556ed4a6895871">cookieGraphToShape</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, <a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons)</td></tr>
<tr class="memdesc:a4f9e95fba88184df22556ed4a6895871"><td class="mdescLeft">&#160;</td><td class="mdescRight">cookieGraphToShape This function removes from the graph all of its vertices that are located outside the boundary specified by the polygons parameter. The function maintains the DCEL structure of the graph.  <br /></td></tr>
<tr class="separator:a4f9e95fba88184df22556ed4a6895871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c166294f71814bd8a78eb2375b3b064"><td class="memItemLeft" align="right" valign="top">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a9c166294f71814bd8a78eb2375b3b064">clipGraphToShape</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, ClipperLib2::Paths clip)</td></tr>
<tr class="memdesc:a9c166294f71814bd8a78eb2375b3b064"><td class="mdescLeft">&#160;</td><td class="mdescRight">clipGraphToShape This function creates and returns a new graph that is the clipped version of the input graph. More specifically, all edges in the input graph are treated as single line segments that are clipped by the boundary shape specified by the clip parameter and then the resulting clipped line segments are connected together where they share endpoints. The returned graph is a DCEL except for the fact that faces are not set up (i.e. no interior faces and all edges have exterior face as leftFace even if visually they are on the “inside”). The overloaded polygons version just converts the polygons to a Paths object, which is easily done since they are practically the same.  <br /></td></tr>
<tr class="separator:a9c166294f71814bd8a78eb2375b3b064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d786efe53559f8f0fb8226fdd5ff63e"><td class="memItemLeft" align="right" valign="top">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a2d786efe53559f8f0fb8226fdd5ff63e">clipGraphToShape</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, <a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons)</td></tr>
<tr class="separator:a2d786efe53559f8f0fb8226fdd5ff63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ec2bbc4ba2ff2f11d5ce53d2ec1cab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a23ec2bbc4ba2ff2f11d5ce53d2ec1cab">pack</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, <a class="el" href="namespace_o_r_n_l.html#a88f4a5aeaf0153351c3e3a27c32ed1f6">Orientation</a> orientation=<a class="el" href="namespace_o_r_n_l.html#a88f4a5aeaf0153351c3e3a27c32ed1f6aa426fbed22f164a05a6af168d18339d9">CLOCKWISE</a>)</td></tr>
<tr class="memdesc:a23ec2bbc4ba2ff2f11d5ce53d2ec1cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">pack This function takes in a graph and applies a circle packing algorithm to modify all the radii and locations of vertices in the graph so that the resulting graph is a circle packing. The circle placing sub-procedure lays out the circles in clockwise orientation by default, but counterclockwise can be specified. This version uses default values for the iteration limit and tolerance (1000 and 0.0000001 respectively). Important note: This process is a major bottleneck in the execution time by far, since this process can take 1-10 minutes depending on the number of vertices in the graph and the desired accuracy.  <br /></td></tr>
<tr class="separator:a23ec2bbc4ba2ff2f11d5ce53d2ec1cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696e9c4b7003f511b3981c8163242602"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a696e9c4b7003f511b3981c8163242602">pack</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, int64_t iteration_limit, double tolerance, <a class="el" href="namespace_o_r_n_l.html#a88f4a5aeaf0153351c3e3a27c32ed1f6">Orientation</a> orientation=<a class="el" href="namespace_o_r_n_l.html#a88f4a5aeaf0153351c3e3a27c32ed1f6aa426fbed22f164a05a6af168d18339d9">CLOCKWISE</a>)</td></tr>
<tr class="memdesc:a696e9c4b7003f511b3981c8163242602"><td class="mdescLeft">&#160;</td><td class="mdescRight">pack It is possible to speed up the packing process by loosening the tolerance or reducing the iteration limit. If there are less than 1000 vertices and packing radii are in the range [10mm, 100mm] then the tolerance can be reduced to 0.000001 and the results will still be sufficient. Conversely, if more accuracy is desired then the tolerance can be tightened if the user doesn’t mind waiting longer.  <br /></td></tr>
<tr class="separator:a696e9c4b7003f511b3981c8163242602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70e51ae9f9a31f810601261727cc9cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#aa70e51ae9f9a31f810601261727cc9cd">getNumOddDegreeVertices</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph)</td></tr>
<tr class="memdesc:aa70e51ae9f9a31f810601261727cc9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">getNumOddDegreeVertices Returns the number of vertices with odd degree.  <br /></td></tr>
<tr class="separator:aa70e51ae9f9a31f810601261727cc9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de8d531fbaa41fc162958c2b52d9630"><td class="memItemLeft" align="right" valign="top">QVector&lt; QVector&lt; QPair&lt; int, int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a5de8d531fbaa41fc162958c2b52d9630">generatePaths</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph)</td></tr>
<tr class="memdesc:a5de8d531fbaa41fc162958c2b52d9630"><td class="mdescLeft">&#160;</td><td class="mdescRight">generatePaths Generates and returns paths for traversing the whole graph with the minimum number of lifting.  <br /></td></tr>
<tr class="separator:a5de8d531fbaa41fc162958c2b52d9630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e194f0f4ccf5879dacef8b6f5d53ff"><td class="memItemLeft" align="right" valign="top">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a22e194f0f4ccf5879dacef8b6f5d53ff">addBarycenterToFace</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_face.html">Face</a> &gt; face)</td></tr>
<tr class="memdesc:a22e194f0f4ccf5879dacef8b6f5d53ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">addBarycenterToFace This function adds a new vertex to the specified face of the given graph. The vertex is placed at the centroid of the face and is given a default radius of half the average of the radii of the corner vertices of the face. In less confusing terms, it looks like it is in the center of the face with an okay radius. The new vertex forms an edge with each corner vertex of the face similar to the spokes on a bicycle wheel. Also the original face is split into N faces where N is the number of edges that formed the original face. This function maintains a proper DCEL.Usage notes: This function is step 1 in the refinement process, but I’m providing direct access to this function in case the advanced user may find this function to be of use in a more general scenario.  <br /></td></tr>
<tr class="separator:a22e194f0f4ccf5879dacef8b6f5d53ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32ae9d8f6da3dbf116dfd64bb724393"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#ac32ae9d8f6da3dbf116dfd64bb724393">flipEdge</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_half_edge.html">HalfEdge</a> &gt; h)</td></tr>
<tr class="memdesc:ac32ae9d8f6da3dbf116dfd64bb724393"><td class="mdescLeft">&#160;</td><td class="mdescRight">flipEdge This function flips the edge specified by the half edge and its twin. In a triangulation, an interior edge is shared by two triangular faces. To 'flip' the edge, we re-orient the edge so that it forms the other diagonal in the union of those two faces. This process removes nothing and adds nothing to the graph, but simply just rearranges references. Note: Make sure the edge provided is not a boundary edge, since for our purposes, forming an edge through the exterior face is undesirable. Also the edge is flipped counter-clockwise and flipping 4 times returns the graph back the way it was before any flipping was done. Usage notes: This function is step 2 in the refinement process, but I’m providing direct access to this function in case the advanced user may find this function to be of use on its own.  <br /></td></tr>
<tr class="separator:ac32ae9d8f6da3dbf116dfd64bb724393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e19e6cfe34d29e2c7337de037d05b2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a9e19e6cfe34d29e2c7337de037d05b2f">eraseBoundaryEdge</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_half_edge.html">HalfEdge</a> &gt; h)</td></tr>
<tr class="memdesc:a9e19e6cfe34d29e2c7337de037d05b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">eraseBoundaryEdge This function removes the edge specified by the half edge and its twin from the given graph. This function maintains a proper DCEL; however, removal of the two half edges and their associated interior face does leave an “index gap” in the set of keys associated with the half edges and faces in the graph. For example, if a graph had 5 faces with keys 0, 1, 2, 3, and 4 and face 2 is removed, then the set of face keys becomes 0, 1, 3, 4. This may or may not be a problem depending on how the graph is further used. If it is necessary to fix the “index gap” then simply call the remap functions in the <a class="el" href="class_o_r_n_l_1_1_graph.html" title="A graph is representation of a set of objects where some pairs of objects are connected by links....">Graph</a> class. The three functions are remapVertices(), remapHalfEdges(), and remapFaces(). Call whichever ones you need. Note: This function is step 3 in the refinement process that only occurs when vertices near the graph boundary are refined and the boundary edges are then erased instead of flipped.  <br /></td></tr>
<tr class="separator:a9e19e6cfe34d29e2c7337de037d05b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f801926c3ad0dadf075aa81402262a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a8f801926c3ad0dadf075aa81402262a4">localRefine</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt; vertices)</td></tr>
<tr class="separator:a8f801926c3ad0dadf075aa81402262a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453ec7a4f311e18ded25645327d87fd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a453ec7a4f311e18ded25645327d87fd9">localRefine</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, <a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons)</td></tr>
<tr class="memdesc:a453ec7a4f311e18ded25645327d87fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">localRefine This function takes in as parameters the graph to be refined and a boundary specified by the polygons. The input graph is altered so that all the faces around the set of graph vertices that were inside the boundary are refined. Note that the graphs now look terrible. This is why packing, explained in the section “Packing Graphs after Refining”, must be done right after.  <br /></td></tr>
<tr class="separator:a453ec7a4f311e18ded25645327d87fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c28d0e3eac6c424b1c653b6afd5ca2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a6c28d0e3eac6c424b1c653b6afd5ca2e">localRefine</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, <a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons, int64_t threshold)</td></tr>
<tr class="memdesc:a6c28d0e3eac6c424b1c653b6afd5ca2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">localRefine This function takes in as parameters the graph to be refined, a boundary specified by the polygons, and a threshold distance. The input graph is altered so that all the faces around the set of graph vertices that were within threshold distance of the boundary are refined. Note that the graphs now look terrible. This is why packing, explained in the section “Packing Graphs after Refining”, must be done right after.  <br /></td></tr>
<tr class="separator:a6c28d0e3eac6c424b1c653b6afd5ca2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e015361ca636b13a4dec1d1937e22e"><td class="memItemLeft" align="right" valign="top">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#aa4e015361ca636b13a4dec1d1937e22e">generateDualGraph</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, <a class="el" href="namespace_o_r_n_l.html#a19898fc8a2ec8f4d870d3b8532c78cf1">BoundaryTabType</a> tab_type=<a class="el" href="namespace_o_r_n_l.html#a19898fc8a2ec8f4d870d3b8532c78cf1aae2ab688115cbe7da880f99a9cadff8d">NONE</a>)</td></tr>
<tr class="memdesc:aa4e015361ca636b13a4dec1d1937e22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">generateDualGraph This function creates and returns a new graph that is the dual of the input graph.  <br /></td></tr>
<tr class="separator:aa4e015361ca636b13a4dec1d1937e22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ed481f5d3f4558b3889480aafa2b8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#ab1ed481f5d3f4558b3889480aafa2b8e">pointWithinThresholdOfBoundary</a> (<a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> p, int64_t threshold, <a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons)</td></tr>
<tr class="memdesc:ab1ed481f5d3f4558b3889480aafa2b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointWithinThresholdOfBoundary It is the bool to check if a point is within threshold of the boundary.  <br /></td></tr>
<tr class="separator:ab1ed481f5d3f4558b3889480aafa2b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ba22347fa2f5242d12f64d84598f9f"><td class="memItemLeft" align="right" valign="top">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a13ba22347fa2f5242d12f64d84598f9f">selectVerticesInside</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, <a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons)</td></tr>
<tr class="memdesc:a13ba22347fa2f5242d12f64d84598f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">selectVerticesInside, selectVerticesOutside, selectVerticesCloseToBoundary, vertexSetUnion  <br /></td></tr>
<tr class="separator:a13ba22347fa2f5242d12f64d84598f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c62d324d4db5c84ce7f5d4af8168f7"><td class="memItemLeft" align="right" valign="top">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a09c62d324d4db5c84ce7f5d4af8168f7">selectVerticesOutside</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, <a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons)</td></tr>
<tr class="separator:a09c62d324d4db5c84ce7f5d4af8168f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6077c11945616776ab1c39a8488f50"><td class="memItemLeft" align="right" valign="top">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a1d6077c11945616776ab1c39a8488f50">selectVerticesCloseToBoundary</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, <a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *polygons, int64_t threshold)</td></tr>
<tr class="separator:a1d6077c11945616776ab1c39a8488f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230b174ca408ec6776cf7e07d89f0e4d"><td class="memItemLeft" align="right" valign="top">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a230b174ca408ec6776cf7e07d89f0e4d">vertexSetUnion</a> (QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt; set1, QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt; set2)</td></tr>
<tr class="separator:a230b174ca408ec6776cf7e07d89f0e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c7636d1e459ca0335804505da1d11a"><td class="memItemLeft" align="right" valign="top">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a50c7636d1e459ca0335804505da1d11a">vertexSetIntersection</a> (QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt; set1, QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt; set2)</td></tr>
<tr class="separator:a50c7636d1e459ca0335804505da1d11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75e5789c860a34f9c7888d6be35d411"><td class="memItemLeft" align="right" valign="top">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#aa75e5789c860a34f9c7888d6be35d411">vertexSetDifference</a> (QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt; set1, QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt; set2)</td></tr>
<tr class="separator:aa75e5789c860a34f9c7888d6be35d411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2613ea17bd299944294dea61046812"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a9e2613ea17bd299944294dea61046812">translateGraph</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, int64_t x_offset, int64_t y_offset)</td></tr>
<tr class="memdesc:a9e2613ea17bd299944294dea61046812"><td class="mdescLeft">&#160;</td><td class="mdescRight">translateGraph, scaleGraph, rotateGraph These utility functions provide an easy way to perform scalings, translations, and rotations on graphs.  <br /></td></tr>
<tr class="separator:a9e2613ea17bd299944294dea61046812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556dc48dd8ef7d15f7b4ab1abdf85bb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a556dc48dd8ef7d15f7b4ab1abdf85bb6">scaleGraph</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, int64_t scale)</td></tr>
<tr class="separator:a556dc48dd8ef7d15f7b4ab1abdf85bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17e2d923546593d97b3e5f15d3ceb3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#ae17e2d923546593d97b3e5f15d3ceb3a">rotateGraph</a> (QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; graph, double degrees, <a class="el" href="namespace_o_r_n_l.html#a88f4a5aeaf0153351c3e3a27c32ed1f6">Orientation</a> orientation=<a class="el" href="namespace_o_r_n_l.html#a88f4a5aeaf0153351c3e3a27c32ed1f6aa426fbed22f164a05a6af168d18339d9">CLOCKWISE</a>)</td></tr>
<tr class="separator:ae17e2d923546593d97b3e5f15d3ceb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284a5446b1ad900ee04e83c3e843f0a8"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a284a5446b1ad900ee04e83c3e843f0a8">getLoadScale</a> ()</td></tr>
<tr class="separator:a284a5446b1ad900ee04e83c3e843f0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a1196c8f126a479d1b9898c354823f"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a20a1196c8f126a479d1b9898c354823f">getIterations</a> ()</td></tr>
<tr class="memdesc:a20a1196c8f126a479d1b9898c354823f"><td class="mdescLeft">&#160;</td><td class="mdescRight">getIterations, getAdjustmentFactor Return, the number of iterations and the adjustment factor on the forces applied to circle centers and radii for each iteration are member fields in the <a class="el" href="class_o_r_n_l_1_1_circle_pack.html">CirclePack</a> class.  <br /></td></tr>
<tr class="separator:a20a1196c8f126a479d1b9898c354823f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c917263b16b280ad03da00176048a4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a22c917263b16b280ad03da00176048a4">getAdjustmentFactor</a> ()</td></tr>
<tr class="separator:a22c917263b16b280ad03da00176048a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c9061a11b8710cf7e0750c28409b24"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a91c9061a11b8710cf7e0750c28409b24">getMinInversiveDist</a> ()</td></tr>
<tr class="memdesc:a91c9061a11b8710cf7e0750c28409b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">getMinInversiveDist, getMaxInversiveDist  <br /></td></tr>
<tr class="separator:a91c9061a11b8710cf7e0750c28409b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0103abdc15cfb5e7548e35b9cc49774"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#ad0103abdc15cfb5e7548e35b9cc49774">getMaxInversiveDist</a> ()</td></tr>
<tr class="separator:ad0103abdc15cfb5e7548e35b9cc49774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4df8a30c4636d6a139a05abad5fbfcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_o_r_n_l.html#ade0cb64d1baa73e302d9487f8698f383">BoundaryMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#ab4df8a30c4636d6a139a05abad5fbfcc">getBoundaryMode</a> ()</td></tr>
<tr class="memdesc:ab4df8a30c4636d6a139a05abad5fbfcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">getBoundaryMode  <br /></td></tr>
<tr class="separator:ab4df8a30c4636d6a139a05abad5fbfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b60cb3a121dcd088ca26107c7be139"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a14b60cb3a121dcd088ca26107c7be139">setLoadScale</a> (int64_t load_scale)</td></tr>
<tr class="separator:a14b60cb3a121dcd088ca26107c7be139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d59dde6de87f20c79d23fdac5c6b7f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a8d59dde6de87f20c79d23fdac5c6b7f0">setIterations</a> (int64_t iterations)</td></tr>
<tr class="memdesc:a8d59dde6de87f20c79d23fdac5c6b7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">setIterations, setAdjustmentFactor The procedure involves an iterative process that runs as a simulation of forces between vertices with their neighboring vertices and vertices with the boundary. The number of iterations and the adjustment factor on the forces applied to circle centers and radii for each iteration are member fields in the <a class="el" href="class_o_r_n_l_1_1_circle_pack.html">CirclePack</a> class. By default, the number of iterations is set to 3000 and adjustment factor is set to 0.01.  <br /></td></tr>
<tr class="separator:a8d59dde6de87f20c79d23fdac5c6b7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1431b0e3747c0a2d54bdd71927e1ade8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a1431b0e3747c0a2d54bdd71927e1ade8">setAdjustmentFactor</a> (double adjustment_factor)</td></tr>
<tr class="separator:a1431b0e3747c0a2d54bdd71927e1ade8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386d49b9be00b65890969429da1e8a9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a386d49b9be00b65890969429da1e8a9e">setMinInversiveDist</a> (double min_inversive_dist)</td></tr>
<tr class="memdesc:a386d49b9be00b65890969429da1e8a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">setMinInversiveDist, setMaxInversiveDist Inversive distances measure and describe the locations of two circles relative to each other. If two circles are exactly tangent and disjoint, then their inversive distance is exactly 1. If two circles are far apart, then their inversive distance is much greater than 1. If two circles are overlapping, then their inversive distance is between -1 and 1. More information about inversive distances can be easily found online (there’s a nice Wikipedia article on it too). Since the objective is to make all the circles of the vertices in the graph tangent and disjoint, we want all the inversive distances to be 1. However, this may not be possible so we relax the constraints on vertices in the graph that are designated as secondary in order to better fit the given boundary. These relaxed constraints are specified by minimum and maximum values for inversive distances to secondary vertices. By default, these member fields in the <a class="el" href="class_o_r_n_l_1_1_circle_pack.html">CirclePack</a> class are set to 0.25 and 4.00 respectively.  <br /></td></tr>
<tr class="separator:a386d49b9be00b65890969429da1e8a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf73c3d7bc45ba5e93c9eb743ca8dd59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#aaf73c3d7bc45ba5e93c9eb743ca8dd59">setMaxInversiveDist</a> (double max_inversive_dist)</td></tr>
<tr class="separator:aaf73c3d7bc45ba5e93c9eb743ca8dd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3569aef78e071370af7a8a3bf3e48c2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html#a3569aef78e071370af7a8a3bf3e48c2f">setBoundaryMode</a> (<a class="el" href="namespace_o_r_n_l.html#ade0cb64d1baa73e302d9487f8698f383">BoundaryMode</a> boundary_mode)</td></tr>
<tr class="memdesc:a3569aef78e071370af7a8a3bf3e48c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">setBoundaryMode The boundary vertices can be fitted to the boundary such that their circle centers are located on the boundary or their circles are tangent to the boundary. This is specified by a member field within the <a class="el" href="class_o_r_n_l_1_1_circle_pack.html">CirclePack</a> class. By default, the boundary mode is set to TANGENT.  <br /></td></tr>
<tr class="separator:a3569aef78e071370af7a8a3bf3e48c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae7520b4b329ef92dc9229557e277dc1e" name="ae7520b4b329ef92dc9229557e277dc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7520b4b329ef92dc9229557e277dc1e">&#9670;&#160;</a></span>CirclePack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORNL::CirclePack::CirclePack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a22e194f0f4ccf5879dacef8b6f5d53ff" name="a22e194f0f4ccf5879dacef8b6f5d53ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e194f0f4ccf5879dacef8b6f5d53ff">&#9670;&#160;</a></span>addBarycenterToFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; ORNL::CirclePack::addBarycenterToFace </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_face.html">Face</a> &gt;&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>addBarycenterToFace This function adds a new vertex to the specified face of the given graph. The vertex is placed at the centroid of the face and is given a default radius of half the average of the radii of the corner vertices of the face. In less confusing terms, it looks like it is in the center of the face with an okay radius. The new vertex forms an edge with each corner vertex of the face similar to the spokes on a bicycle wheel. Also the original face is split into N faces where N is the number of edges that formed the original face. This function maintains a proper DCEL.Usage notes: This function is step 1 in the refinement process, but I’m providing direct access to this function in case the advanced user may find this function to be of use in a more general scenario. </p>
<p>addBarycenterToFace - Adds a barycenter to the specified face of the graph. A barycenter is defined as a vertex inside a face that is connected to every corner vertex of the face. The barycenter is set at the centroid of the face and the radius of the circle associated with the barycenter is half the average of all of its neighbors. If the face has E edges, then addition of the barycenter will create 1 new vertex, create E - 1 new faces, and create and set up 2*E new halfEdges. There are E - 1 new faces because the old face is reused as one of the new ones in order to avoid having to re-map all the faces in the graph. Re-mapping would otherwise be necessary since the face key of the new faces is determined by the number of existing faces in the graph and thus deleting a face would cause overlaps in the face keys of new faces leading to multiple serious issues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph*</td><td>graph must be a properly set up DCEL. </td></tr>
    <tr><td class="paramname">Face*</td><td>face must have a boundary halfEdge != nullptr, else segfault.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly created barycenter or nullptr if one of the parameters was a nullptr. </dd></dl>

</div>
</div>
<a id="a9c166294f71814bd8a78eb2375b3b064" name="a9c166294f71814bd8a78eb2375b3b064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c166294f71814bd8a78eb2375b3b064">&#9670;&#160;</a></span>clipGraphToShape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; ORNL::CirclePack::clipGraphToShape </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ClipperLib2::Paths&#160;</td>
          <td class="paramname"><em>clip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clipGraphToShape This function creates and returns a new graph that is the clipped version of the input graph. More specifically, all edges in the input graph are treated as single line segments that are clipped by the boundary shape specified by the clip parameter and then the resulting clipped line segments are connected together where they share endpoints. The returned graph is a DCEL except for the fact that faces are not set up (i.e. no interior faces and all edges have exterior face as leftFace even if visually they are on the “inside”). The overloaded polygons version just converts the polygons to a Paths object, which is easily done since they are practically the same. </p>
<p>clipGraphToShape - Returns a new graph that is the clipped version of the input graph. The clipping shape is determined by the paths with the first path being the outer boundary of the shape and the remaining paths being "holes" in the shape. The returned graph is a DCEL; however, the faces are not set up (every edge has exterior as leftFace). </p>

</div>
</div>
<a id="a2d786efe53559f8f0fb8226fdd5ff63e" name="a2d786efe53559f8f0fb8226fdd5ff63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d786efe53559f8f0fb8226fdd5ff63e">&#9670;&#160;</a></span>clipGraphToShape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; ORNL::CirclePack::clipGraphToShape </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>clipGraphToShape - This version takes in a Polygons object, converts it to a Paths object and calls the other method to do the actual clipping. </p>

</div>
</div>
<a id="a4f9e95fba88184df22556ed4a6895871" name="a4f9e95fba88184df22556ed4a6895871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9e95fba88184df22556ed4a6895871">&#9670;&#160;</a></span>cookieGraphToShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::cookieGraphToShape </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cookieGraphToShape This function removes from the graph all of its vertices that are located outside the boundary specified by the polygons parameter. The function maintains the DCEL structure of the graph. </p>
<p>cookieGraphToShape - Cookie cuts the graph using the cookie cutter shape specified by the polygons. The first polygon determines the outer boundary of the shape and the remaining polygons determine "holes" within the shape. Vertices that lie outside the cookie cutter shape are removed along with all the edges that have those vertices as either end-point. Also, all the interior faces associated with those vertices are also removed and the exposed interior edges have the exterior face set as their leftFace. </p>

</div>
</div>
<a id="a9e19e6cfe34d29e2c7337de037d05b2f" name="a9e19e6cfe34d29e2c7337de037d05b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e19e6cfe34d29e2c7337de037d05b2f">&#9670;&#160;</a></span>eraseBoundaryEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::eraseBoundaryEdge </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_half_edge.html">HalfEdge</a> &gt;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>eraseBoundaryEdge This function removes the edge specified by the half edge and its twin from the given graph. This function maintains a proper DCEL; however, removal of the two half edges and their associated interior face does leave an “index gap” in the set of keys associated with the half edges and faces in the graph. For example, if a graph had 5 faces with keys 0, 1, 2, 3, and 4 and face 2 is removed, then the set of face keys becomes 0, 1, 3, 4. This may or may not be a problem depending on how the graph is further used. If it is necessary to fix the “index gap” then simply call the remap functions in the <a class="el" href="class_o_r_n_l_1_1_graph.html" title="A graph is representation of a set of objects where some pairs of objects are connected by links....">Graph</a> class. The three functions are remapVertices(), remapHalfEdges(), and remapFaces(). Call whichever ones you need. Note: This function is step 3 in the refinement process that only occurs when vertices near the graph boundary are refined and the boundary edges are then erased instead of flipped. </p>
<p>eraseBoundaryEdge - Erases the specified boundary edge in the graph and properly updates the affected half edges. This method removes 2 halfEdges and the 1 interior face that was associated with the removed edge. Thus there will now be an 'index gap' in the graph for both faces and halfEdges that may need to be fixed for certain operations on the graph. </p>

</div>
</div>
<a id="a0c50fc4c50aa5106e03cddd7f65bb543" name="a0c50fc4c50aa5106e03cddd7f65bb543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c50fc4c50aa5106e03cddd7f65bb543">&#9670;&#160;</a></span>FieldPackGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::FieldPackGraph </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_field.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>radius_delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FieldPackGraph ?? </p>

</div>
</div>
<a id="a41792410b9c25cd19c96fd25eac551f4" name="a41792410b9c25cd19c96fd25eac551f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41792410b9c25cd19c96fd25eac551f4">&#9670;&#160;</a></span>fitGraphToBoundary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::fitGraphToBoundary </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fitGraphToBoundary This function adjusts the locations and radii of the vertices in the given graph to minimize circle overlaps while also maximizing the conformity of the overall graph shape to the given boundary specified by the polygons. Usage notes: This function tends to work best with graphs that already fit inside the boundary such as those generated by the contained graph generators. This function usually does not work well with graphs that have large hollow spaces internally which are typical of many dual graphs. </p>

</div>
</div>
<a id="a7d4deb2ca04f550169915ca615acd05e" name="a7d4deb2ca04f550169915ca615acd05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4deb2ca04f550169915ca615acd05e">&#9670;&#160;</a></span>fitGraphToBoundary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::fitGraphToBoundary </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac32ae9d8f6da3dbf116dfd64bb724393" name="ac32ae9d8f6da3dbf116dfd64bb724393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32ae9d8f6da3dbf116dfd64bb724393">&#9670;&#160;</a></span>flipEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::flipEdge </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_half_edge.html">HalfEdge</a> &gt;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flipEdge This function flips the edge specified by the half edge and its twin. In a triangulation, an interior edge is shared by two triangular faces. To 'flip' the edge, we re-orient the edge so that it forms the other diagonal in the union of those two faces. This process removes nothing and adds nothing to the graph, but simply just rearranges references. Note: Make sure the edge provided is not a boundary edge, since for our purposes, forming an edge through the exterior face is undesirable. Also the edge is flipped counter-clockwise and flipping 4 times returns the graph back the way it was before any flipping was done. Usage notes: This function is step 2 in the refinement process, but I’m providing direct access to this function in case the advanced user may find this function to be of use on its own. </p>
<p>flipEdge - Flips the edge specified by the halfEdge and its twin. In a triangulation, an interior edge is shared by two triangular faces. To 'flip' the edge, we re-orient the edge so that it forms the other diagonal in the union of those two faces. This process removes nothing and adds nothing to the graph, but simply just rearranges pointers. Note: Make sure the edge provided is not a boundary edge, since for our purposes, forming an edge through the exterior face is undesirable. Also the edge is flipped counter-clockwise and 4 flips == 0 flips. </p>

</div>
</div>
<a id="a45509d6a95b4b620eead9b0886ae99d4" name="a45509d6a95b4b620eead9b0886ae99d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45509d6a95b4b620eead9b0886ae99d4">&#9670;&#160;</a></span>generateContainedHexGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; ORNL::CirclePack::generateContainedHexGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>edge_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>set_secondary</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af82ffb3e580029ec0706c9ec9104c466" name="af82ffb3e580029ec0706c9ec9104c466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82ffb3e580029ec0706c9ec9104c466">&#9670;&#160;</a></span>generateContainedHexGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; ORNL::CirclePack::generateContainedHexGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>edge_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>y_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>set_secondary</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abaab035d96c013619dae08eb42586902" name="abaab035d96c013619dae08eb42586902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaab035d96c013619dae08eb42586902">&#9670;&#160;</a></span>generateContainedSquareGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; ORNL::CirclePack::generateContainedSquareGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>edge_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_secondary</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generateContainedSquareGrid, generateContainedHexGrid These functions generate square and hex grids, respectively, within a boundary specified by the polygons parameter with grid edges of the specified length. The overloaded versions provide the option to directly specify the offsets, rows, and columns for generating the initial grids of which a subset contained within the boundary is returned. The simple versions guarantee that the space within the boundary will be filled as fully as possible, while the overloaded versions do not guarantee this since the user will be directly controlling the generation of the initial grids. Also, in the <a class="el" href="class_o_r_n_l_1_1_circle_pack.html">CirclePack</a> object there is a “boundary_mode” field with possible values TANGENT and CENTER. By default, when a <a class="el" href="class_o_r_n_l_1_1_circle_pack.html">CirclePack</a> object is created, the “boundary_mode” field is set to TANGENT. These modes will be explained later in the section “Fitting Graphs to Boundaries”, but if the “boundary_mode” is set to CENTER, then extra vertices that touch inside of the boundaries (but have centers outside) are also included in the returned graph. The optional parameters “include_secondary” and “set_secondary” are explained in section “Uniform Graphs”. </p>

</div>
</div>
<a id="a0042f2c766976b240bfe28b027ab687c" name="a0042f2c766976b240bfe28b027ab687c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0042f2c766976b240bfe28b027ab687c">&#9670;&#160;</a></span>generateContainedSquareGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; ORNL::CirclePack::generateContainedSquareGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>edge_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>y_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_secondary</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4e015361ca636b13a4dec1d1937e22e" name="aa4e015361ca636b13a4dec1d1937e22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e015361ca636b13a4dec1d1937e22e">&#9670;&#160;</a></span>generateDualGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; ORNL::CirclePack::generateDualGraph </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_r_n_l.html#a19898fc8a2ec8f4d870d3b8532c78cf1">BoundaryTabType</a>&#160;</td>
          <td class="paramname"><em>tab_type</em> = <code><a class="el" href="namespace_o_r_n_l.html#a19898fc8a2ec8f4d870d3b8532c78cf1aae2ab688115cbe7da880f99a9cadff8d">NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generateDualGraph This function creates and returns a new graph that is the dual of the input graph. </p>
<p>generateDualGraph - Returns a new DCEL graph that is the dual of the input DCEL graph. The dual will have 1 vertex for every face, 1 face for every internal vertex, and 1 edge for every internal edge. If "boundary tabs" are also included, then there will also be a "boundary tab" edge for every boundary edge in the input graph along with additional vertices that form the leaf end-points of those boundary tabs. The location of the additional vertices is specified by the input parameter. Note: The boundary edges of the dual graph faces move counter-clockwise. </p>

</div>
</div>
<a id="af17d9bcf0f231fe0e7b5f0b0c665ae55" name="af17d9bcf0f231fe0e7b5f0b0c665ae55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17d9bcf0f231fe0e7b5f0b0c665ae55">&#9670;&#160;</a></span>generateEnvelopingHexGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; ORNL::CirclePack::generateEnvelopingHexGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>edge_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>set_secondary</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0965c5bd1f18e43a1c20972d3fc7a661" name="a0965c5bd1f18e43a1c20972d3fc7a661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0965c5bd1f18e43a1c20972d3fc7a661">&#9670;&#160;</a></span>generateEnvelopingSquareGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; ORNL::CirclePack::generateEnvelopingSquareGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>edge_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_secondary</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generateEnvelopingSquareGrid, generateEnvelopingHexGrid These functions generate square and hex grids, respectively, that envelop the boundary specified by the polygons parameter with grid edges of the specified length. The size of the envelop is determined by the margin parameter which specifies the desired distance between the outermost vertices and the boundary. The optional parameters “include_secondary” and “set_secondary” are explained in section “Uniform Graphs”. These functions tend to be the most useful when refinements are desired. This is because refinements do not guarantee that the overall shape of the graph will remain the same after packing, but if only internal vertices that are relatively at a distance from the boundary are refined then the overall shape tends to remain very similar. However, we don’t want a huge margin either because that slows down the packing process. Thus when using these methods, a good margin tends to be around 2-3 times the edge length. </p>

</div>
</div>
<a id="a5de8d531fbaa41fc162958c2b52d9630" name="a5de8d531fbaa41fc162958c2b52d9630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de8d531fbaa41fc162958c2b52d9630">&#9670;&#160;</a></span>generatePaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QVector&lt; QVector&lt; QPair&lt; int, int &gt; &gt; &gt; ORNL::CirclePack::generatePaths </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generatePaths Generates and returns paths for traversing the whole graph with the minimum number of lifting. </p>
<p>generatePaths - Generates and returns paths for traversing the whole graph. The returning vector contains several vectors where each vector is a continuous path. Each continuous path contains sevaral pairs where each pair corresponds to an edge in graph. The first integer in a pair is vertex key of the starting vertex and the second integer is vertex key of the ending vertex on this edge. For example, {(1,3), (3,5), (5,10)} represents the continuous path 1-&gt;3-&gt;5-&gt;10. So size of returning vector is one plus the number of lifting during traversing the whole graph.</p>
<p>Created by Yifan Wang on 08/01/2018. </p>

</div>
</div>
<a id="af4e021a67368ef67cb5660574197fd07" name="af4e021a67368ef67cb5660574197fd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e021a67368ef67cb5660574197fd07">&#9670;&#160;</a></span>generateUniformHexGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; ORNL::CirclePack::generateUniformHexGrid </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>edge_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>y_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>set_secondary</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2390e74369a7de0dac45c9184c4d72c4" name="a2390e74369a7de0dac45c9184c4d72c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2390e74369a7de0dac45c9184c4d72c4">&#9670;&#160;</a></span>generateUniformSquareGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt; ORNL::CirclePack::generateUniformSquareGrid </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>edge_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>y_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_secondary</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generateUniformSquareGrid, generateUniformHexGrid These functions take in as parameters the x and y coordinates of the first vertex in the graph, the length of the edges in the graph, and the number of rows and columns in the graph. For the square version, the output is a uniform square grid with secondary vertices included by default in the interstices. Optionally, passing in false to the “include_secondary” parameter will leave these out. For the hex version, the output is a uniform hexagonal grid composed of equilateral triangles. Optionally, passing in true to the “set_secondary” parameter will set specific vertices in the hex grid as secondary vertices so that all secondary vertices are separated from neighboring secondary vertices by exactly one line of vertices. </p>

</div>
</div>
<a id="a22c917263b16b280ad03da00176048a4" name="a22c917263b16b280ad03da00176048a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c917263b16b280ad03da00176048a4">&#9670;&#160;</a></span>getAdjustmentFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ORNL::CirclePack::getAdjustmentFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4df8a30c4636d6a139a05abad5fbfcc" name="ab4df8a30c4636d6a139a05abad5fbfcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4df8a30c4636d6a139a05abad5fbfcc">&#9670;&#160;</a></span>getBoundaryMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_o_r_n_l.html#ade0cb64d1baa73e302d9487f8698f383">BoundaryMode</a> ORNL::CirclePack::getBoundaryMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getBoundaryMode </p>
<dl class="section return"><dt>Returns</dt><dd>Boundary Mode for circle packing . There are two possible output CENTER and TANGENT. </dd></dl>

</div>
</div>
<a id="a20a1196c8f126a479d1b9898c354823f" name="a20a1196c8f126a479d1b9898c354823f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a1196c8f126a479d1b9898c354823f">&#9670;&#160;</a></span>getIterations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ORNL::CirclePack::getIterations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getIterations, getAdjustmentFactor Return, the number of iterations and the adjustment factor on the forces applied to circle centers and radii for each iteration are member fields in the <a class="el" href="class_o_r_n_l_1_1_circle_pack.html">CirclePack</a> class. </p>

</div>
</div>
<a id="a284a5446b1ad900ee04e83c3e843f0a8" name="a284a5446b1ad900ee04e83c3e843f0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284a5446b1ad900ee04e83c3e843f0a8">&#9670;&#160;</a></span>getLoadScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ORNL::CirclePack::getLoadScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0103abdc15cfb5e7548e35b9cc49774" name="ad0103abdc15cfb5e7548e35b9cc49774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0103abdc15cfb5e7548e35b9cc49774">&#9670;&#160;</a></span>getMaxInversiveDist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ORNL::CirclePack::getMaxInversiveDist </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91c9061a11b8710cf7e0750c28409b24" name="a91c9061a11b8710cf7e0750c28409b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c9061a11b8710cf7e0750c28409b24">&#9670;&#160;</a></span>getMinInversiveDist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ORNL::CirclePack::getMinInversiveDist </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getMinInversiveDist, getMaxInversiveDist </p>
<dl class="section return"><dt>Returns</dt><dd>maximum and minimum inverse distance measure throughout the graph. </dd></dl>

</div>
</div>
<a id="aa70e51ae9f9a31f810601261727cc9cd" name="aa70e51ae9f9a31f810601261727cc9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70e51ae9f9a31f810601261727cc9cd">&#9670;&#160;</a></span>getNumOddDegreeVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORNL::CirclePack::getNumOddDegreeVertices </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getNumOddDegreeVertices Returns the number of vertices with odd degree. </p>
<p>getNumOddDegreeVertices - Returns the number of vertices with odd degree.</p>
<p>Created by Yifan Wang on 08/01/2018. </p>

</div>
</div>
<a id="a453ec7a4f311e18ded25645327d87fd9" name="a453ec7a4f311e18ded25645327d87fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453ec7a4f311e18ded25645327d87fd9">&#9670;&#160;</a></span>localRefine() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::localRefine </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>localRefine This function takes in as parameters the graph to be refined and a boundary specified by the polygons. The input graph is altered so that all the faces around the set of graph vertices that were inside the boundary are refined. Note that the graphs now look terrible. This is why packing, explained in the section “Packing Graphs after Refining”, must be done right after. </p>
<p>localRefine - Given a graph, refine all the vertices in the graph that are inside the boundary shape specified by the polygons parameter. </p>

</div>
</div>
<a id="a6c28d0e3eac6c424b1c653b6afd5ca2e" name="a6c28d0e3eac6c424b1c653b6afd5ca2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c28d0e3eac6c424b1c653b6afd5ca2e">&#9670;&#160;</a></span>localRefine() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::localRefine </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>localRefine This function takes in as parameters the graph to be refined, a boundary specified by the polygons, and a threshold distance. The input graph is altered so that all the faces around the set of graph vertices that were within threshold distance of the boundary are refined. Note that the graphs now look terrible. This is why packing, explained in the section “Packing Graphs after Refining”, must be done right after. </p>
<p>localRefine - Given a graph, refine all the vertices in the graph that are within threshold distance of the boundary shape specified by the polygons parameter. </p>

</div>
</div>
<a id="a8f801926c3ad0dadf075aa81402262a4" name="a8f801926c3ad0dadf075aa81402262a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f801926c3ad0dadf075aa81402262a4">&#9670;&#160;</a></span>localRefine() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::localRefine </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>localRefine - Given a graph and a set of vertices, refine all the faces in the graph that are tangent to one or more vertices in the set. The basic process of refinement is adding barycenters to all the selected faces, flipping all interior edges that connected the vertices in the set to instead connect the new barycenters, and then finally removing any boundary edges (edges on the exterior of the entire graph) that were tangent to vertices in the set. </p>

</div>
</div>
<a id="a696e9c4b7003f511b3981c8163242602" name="a696e9c4b7003f511b3981c8163242602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696e9c4b7003f511b3981c8163242602">&#9670;&#160;</a></span>pack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::pack </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>iteration_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_r_n_l.html#a88f4a5aeaf0153351c3e3a27c32ed1f6">Orientation</a>&#160;</td>
          <td class="paramname"><em>orientation</em> = <code><a class="el" href="namespace_o_r_n_l.html#a88f4a5aeaf0153351c3e3a27c32ed1f6aa426fbed22f164a05a6af168d18339d9">CLOCKWISE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pack It is possible to speed up the packing process by loosening the tolerance or reducing the iteration limit. If there are less than 1000 vertices and packing radii are in the range [10mm, 100mm] then the tolerance can be reduced to 0.000001 and the results will still be sufficient. Conversely, if more accuracy is desired then the tolerance can be tightened if the user doesn’t mind waiting longer. </p>
<p>pack - This overloaded version also takes in the iteration limit and tolerance that it uses when setting the packing radii.</p>
<p>Created by Yifan Wang on 07/20/2018. </p>

</div>
</div>
<a id="a23ec2bbc4ba2ff2f11d5ce53d2ec1cab" name="a23ec2bbc4ba2ff2f11d5ce53d2ec1cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ec2bbc4ba2ff2f11d5ce53d2ec1cab">&#9670;&#160;</a></span>pack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::pack </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_r_n_l.html#a88f4a5aeaf0153351c3e3a27c32ed1f6">Orientation</a>&#160;</td>
          <td class="paramname"><em>orientation</em> = <code><a class="el" href="namespace_o_r_n_l.html#a88f4a5aeaf0153351c3e3a27c32ed1f6aa426fbed22f164a05a6af168d18339d9">CLOCKWISE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pack This function takes in a graph and applies a circle packing algorithm to modify all the radii and locations of vertices in the graph so that the resulting graph is a circle packing. The circle placing sub-procedure lays out the circles in clockwise orientation by default, but counterclockwise can be specified. This version uses default values for the iteration limit and tolerance (1000 and 0.0000001 respectively). Important note: This process is a major bottleneck in the execution time by far, since this process can take 1-10 minutes depending on the number of vertices in the graph and the desired accuracy. </p>
<p>pack - Given a triangulation in the form of a graph along with defined boundary conditions and set radii for boundary vertices, this method modifies the given graph into a circle packing that is unique to the provided input combinatorics and boundary settings up to planar rotations and translations. The optional orientation parameter specifies whether the circles should be laid out clockwise or counterclockwise. By default it is clockwise.</p>
<p>Created by Yifan Wang on 07/20/2018. </p>

</div>
</div>
<a id="ab1ed481f5d3f4558b3889480aafa2b8e" name="ab1ed481f5d3f4558b3889480aafa2b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ed481f5d3f4558b3889480aafa2b8e">&#9670;&#160;</a></span>pointWithinThresholdOfBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ORNL::CirclePack::pointWithinThresholdOfBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointWithinThresholdOfBoundary It is the bool to check if a point is within threshold of the boundary. </p>
<p>pointWithinThresholdOfBoundary - Returns true if the given point is within the threshold distance of the boundary shape specified by the polygons, and returns false if otherwise. </p>

</div>
</div>
<a id="ac04581a62e9e6f0572bfd0e67b9473f0" name="ac04581a62e9e6f0572bfd0e67b9473f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04581a62e9e6f0572bfd0e67b9473f0">&#9670;&#160;</a></span>pruneGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::pruneGraph </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_neighbors</em> = <code><a class="el" href="namespace_o_r_n_l.html#a32447aecab629191e3ca4c4ca2f3e08a">DEFAULT_MIN_NEIGHBORS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_neighbors_secondary</em> = <code><a class="el" href="namespace_o_r_n_l.html#a507f4ea7306a16188f8341d3615789a2">DEFAULT_MIN_NEIGHBORS_FOR_SECONDARY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pruneGraph This function continuously removes all isolated vertices, vertices with less than the specified minimum number of neighbors, and secondary vertices with less than the specified minimum number of neighbors until no more vertices are valid for removal. The default numbers are 2 and 3 for regular vertices and secondary vertices, respectively. </p>
<p>pruneGraph - Removes all isolated vertices, vertices with less than the specified minimum number of neighbors, and also secondary vertices with less than the specified minimum number of neighbors. </p>

</div>
</div>
<a id="a0d617ca1e38e24c56a74701717e60abb" name="a0d617ca1e38e24c56a74701717e60abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d617ca1e38e24c56a74701717e60abb">&#9670;&#160;</a></span>removeInternalSecondary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::removeInternalSecondary </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removeInternalSecondary This function removes all non-boundary vertices that are marked as secondary from the given graph. </p>
<p>removeInternalSecondary - Removes the internal secondary vertices of the graph and maintains the DCEL. </p>

</div>
</div>
<a id="a24335fc5f7a34005a60bef70e4b7f78d" name="a24335fc5f7a34005a60bef70e4b7f78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24335fc5f7a34005a60bef70e4b7f78d">&#9670;&#160;</a></span>removeVertexSelection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::removeVertexSelection </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>removal_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removeVertexSelection This function removes from the graph the subset of its vertices given in the removal set. This function is actually extremely versatile as it can remove any selection of vertices from the graph. Also this function maintains a proper DCEL graph, which is a very important property for a large portion of the code in <a class="el" href="class_o_r_n_l_1_1_circle_pack.html">CirclePack</a>. </p>

</div>
</div>
<a id="ae17e2d923546593d97b3e5f15d3ceb3a" name="ae17e2d923546593d97b3e5f15d3ceb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17e2d923546593d97b3e5f15d3ceb3a">&#9670;&#160;</a></span>rotateGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::rotateGraph </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_r_n_l.html#a88f4a5aeaf0153351c3e3a27c32ed1f6">Orientation</a>&#160;</td>
          <td class="paramname"><em>orientation</em> = <code><a class="el" href="namespace_o_r_n_l.html#a88f4a5aeaf0153351c3e3a27c32ed1f6aa426fbed22f164a05a6af168d18339d9">CLOCKWISE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a556dc48dd8ef7d15f7b4ab1abdf85bb6" name="a556dc48dd8ef7d15f7b4ab1abdf85bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556dc48dd8ef7d15f7b4ab1abdf85bb6">&#9670;&#160;</a></span>scaleGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::scaleGraph </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d6077c11945616776ab1c39a8488f50" name="a1d6077c11945616776ab1c39a8488f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6077c11945616776ab1c39a8488f50">&#9670;&#160;</a></span>selectVerticesCloseToBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt; ORNL::CirclePack::selectVerticesCloseToBoundary </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13ba22347fa2f5242d12f64d84598f9f" name="a13ba22347fa2f5242d12f64d84598f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ba22347fa2f5242d12f64d84598f9f">&#9670;&#160;</a></span>selectVerticesInside()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt; ORNL::CirclePack::selectVerticesInside </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>selectVerticesInside, selectVerticesOutside, selectVerticesCloseToBoundary, vertexSetUnion </p>
<p>vertexSetIntersection, vertexSetDifference These functions provide an easy way to select groups of vertices in the graph. The first three functions return a subset of vertices in the given graph that are inside, outside, or within the specified threshold distance of the boundary specified by the polygons. The last three functions perform set operations on vertex sets. The union operation combines both input sets into one set (through the uniqueness property of sets, there will not be duplicates). The intersection operation returns the set of vertices that were present in both input sets. The difference operation returns the set of vertices in the first input set that were not in the second input set. Usage Notes: The vertex sets obtained from these functions can be used to selectively refine vertices in graphs or selectively delete vertices from graphs among other possible uses.Other ways to select vertices can be manually directly selecting specific vertices from a graph; right now this is not user friendly, but perhaps when a graphical user interface is built for all this stuff then users can point and click on circles in a graphical display of the graphs to select or deselect vertices. </p>

</div>
</div>
<a id="a09c62d324d4db5c84ce7f5d4af8168f7" name="a09c62d324d4db5c84ce7f5d4af8168f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c62d324d4db5c84ce7f5d4af8168f7">&#9670;&#160;</a></span>selectVerticesOutside()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt; ORNL::CirclePack::selectVerticesOutside </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_polygon_list.html">PolygonList</a> *&#160;</td>
          <td class="paramname"><em>polygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1431b0e3747c0a2d54bdd71927e1ade8" name="a1431b0e3747c0a2d54bdd71927e1ade8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1431b0e3747c0a2d54bdd71927e1ade8">&#9670;&#160;</a></span>setAdjustmentFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::setAdjustmentFactor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>adjustment_factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3569aef78e071370af7a8a3bf3e48c2f" name="a3569aef78e071370af7a8a3bf3e48c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3569aef78e071370af7a8a3bf3e48c2f">&#9670;&#160;</a></span>setBoundaryMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::setBoundaryMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_o_r_n_l.html#ade0cb64d1baa73e302d9487f8698f383">BoundaryMode</a>&#160;</td>
          <td class="paramname"><em>boundary_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>setBoundaryMode The boundary vertices can be fitted to the boundary such that their circle centers are located on the boundary or their circles are tangent to the boundary. This is specified by a member field within the <a class="el" href="class_o_r_n_l_1_1_circle_pack.html">CirclePack</a> class. By default, the boundary mode is set to TANGENT. </p>

</div>
</div>
<a id="a8d59dde6de87f20c79d23fdac5c6b7f0" name="a8d59dde6de87f20c79d23fdac5c6b7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d59dde6de87f20c79d23fdac5c6b7f0">&#9670;&#160;</a></span>setIterations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::setIterations </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>iterations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>setIterations, setAdjustmentFactor The procedure involves an iterative process that runs as a simulation of forces between vertices with their neighboring vertices and vertices with the boundary. The number of iterations and the adjustment factor on the forces applied to circle centers and radii for each iteration are member fields in the <a class="el" href="class_o_r_n_l_1_1_circle_pack.html">CirclePack</a> class. By default, the number of iterations is set to 3000 and adjustment factor is set to 0.01. </p>

</div>
</div>
<a id="a14b60cb3a121dcd088ca26107c7be139" name="a14b60cb3a121dcd088ca26107c7be139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b60cb3a121dcd088ca26107c7be139">&#9670;&#160;</a></span>setLoadScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::setLoadScale </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>load_scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf73c3d7bc45ba5e93c9eb743ca8dd59" name="aaf73c3d7bc45ba5e93c9eb743ca8dd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf73c3d7bc45ba5e93c9eb743ca8dd59">&#9670;&#160;</a></span>setMaxInversiveDist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::setMaxInversiveDist </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_inversive_dist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a386d49b9be00b65890969429da1e8a9e" name="a386d49b9be00b65890969429da1e8a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386d49b9be00b65890969429da1e8a9e">&#9670;&#160;</a></span>setMinInversiveDist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::setMinInversiveDist </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_inversive_dist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>setMinInversiveDist, setMaxInversiveDist Inversive distances measure and describe the locations of two circles relative to each other. If two circles are exactly tangent and disjoint, then their inversive distance is exactly 1. If two circles are far apart, then their inversive distance is much greater than 1. If two circles are overlapping, then their inversive distance is between -1 and 1. More information about inversive distances can be easily found online (there’s a nice Wikipedia article on it too). Since the objective is to make all the circles of the vertices in the graph tangent and disjoint, we want all the inversive distances to be 1. However, this may not be possible so we relax the constraints on vertices in the graph that are designated as secondary in order to better fit the given boundary. These relaxed constraints are specified by minimum and maximum values for inversive distances to secondary vertices. By default, these member fields in the <a class="el" href="class_o_r_n_l_1_1_circle_pack.html">CirclePack</a> class are set to 0.25 and 4.00 respectively. </p>

</div>
</div>
<a id="a9e2613ea17bd299944294dea61046812" name="a9e2613ea17bd299944294dea61046812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2613ea17bd299944294dea61046812">&#9670;&#160;</a></span>translateGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::CirclePack::translateGraph </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_graph.html">Graph</a> &gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>y_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>translateGraph, scaleGraph, rotateGraph These utility functions provide an easy way to perform scalings, translations, and rotations on graphs. </p>

</div>
</div>
<a id="aa75e5789c860a34f9c7888d6be35d411" name="aa75e5789c860a34f9c7888d6be35d411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75e5789c860a34f9c7888d6be35d411">&#9670;&#160;</a></span>vertexSetDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt; ORNL::CirclePack::vertexSetDifference </td>
          <td>(</td>
          <td class="paramtype">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>set1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>set2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>vertexSetDifference - Returns a new set of vertices that contains the elements in the first set that are not in the second set. </p>

</div>
</div>
<a id="a50c7636d1e459ca0335804505da1d11a" name="a50c7636d1e459ca0335804505da1d11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c7636d1e459ca0335804505da1d11a">&#9670;&#160;</a></span>vertexSetIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt; ORNL::CirclePack::vertexSetIntersection </td>
          <td>(</td>
          <td class="paramtype">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>set1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>set2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>vertexSetIntersection - Returns a new set of vertices that is the intersection of the two given sets. </p>

</div>
</div>
<a id="a230b174ca408ec6776cf7e07d89f0e4d" name="a230b174ca408ec6776cf7e07d89f0e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230b174ca408ec6776cf7e07d89f0e4d">&#9670;&#160;</a></span>vertexSetUnion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt; ORNL::CirclePack::vertexSetUnion </td>
          <td>(</td>
          <td class="paramtype">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>set1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSet&lt; QSharedPointer&lt; <a class="el" href="class_o_r_n_l_1_1_vertex.html">Vertex</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>set2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>vertexSetUnion - Returns a new set of vertices that is the union of the two given sets. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Code/ORNL-Slicer-2-dev/include/graph/circlepack/<a class="el" href="circlepack_8h_source.html">circlepack.h</a></li>
<li>C:/Code/ORNL-Slicer-2-dev/src/graph/circlepack/<a class="el" href="circlepack_8cpp.html">circlepack.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_o_r_n_l.html">ORNL</a></li><li class="navelem"><a class="el" href="class_o_r_n_l_1_1_circle_pack.html">CirclePack</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
