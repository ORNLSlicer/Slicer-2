<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Slicer 2: ORNL::MathUtils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Slicer 2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespace_o_r_n_l_1_1_math_utils.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ORNL::MathUtils Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Commonly used math functions.  
<a href="namespace_o_r_n_l_1_1_math_utils.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab741e2fe56626b447e355869496fd9df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#ab741e2fe56626b447e355869496fd9df">equals</a> (double a, double b)</td></tr>
<tr class="memdesc:ab741e2fe56626b447e355869496fd9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function that compares two doubles  <br /></td></tr>
<tr class="separator:ab741e2fe56626b447e355869496fd9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24e9236be072bf16a9846d3f6156583"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#aa24e9236be072bf16a9846d3f6156583">equals</a> (double a, double b, double eps)</td></tr>
<tr class="separator:aa24e9236be072bf16a9846d3f6156583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ed4d00b49500f2a31249e10e4e1825"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a45ed4d00b49500f2a31249e10e4e1825">glEquals</a> (double a, double b)</td></tr>
<tr class="memdesc:a45ed4d00b49500f2a31249e10e4e1825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two doubles but with a higher epsilon for.  <br /></td></tr>
<tr class="separator:a45ed4d00b49500f2a31249e10e4e1825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e07cebd1635fd5676cccbdafeb449b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a70e07cebd1635fd5676cccbdafeb449b">notEquals</a> (double a, double b)</td></tr>
<tr class="memdesc:a70e07cebd1635fd5676cccbdafeb449b"><td class="mdescLeft">&#160;</td><td class="mdescRight">a function that compares two doubles  <br /></td></tr>
<tr class="separator:a70e07cebd1635fd5676cccbdafeb449b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736452ad174b8b24f405740d1d46bdae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a736452ad174b8b24f405740d1d46bdae">center</a> (QVector&lt; <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> &gt; points)</td></tr>
<tr class="memdesc:a736452ad174b8b24f405740d1d46bdae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the center of a group of points.  <br /></td></tr>
<tr class="separator:a736452ad174b8b24f405740d1d46bdae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf74dd717d1ff56795e5ca2ab7b0b50"><td class="memItemLeft" align="right" valign="top">Angle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#acdf74dd717d1ff56795e5ca2ab7b0b50">internalAngle</a> (<a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> A, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> B, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> C)</td></tr>
<tr class="memdesc:acdf74dd717d1ff56795e5ca2ab7b0b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates angle at origin between two points. Given A, B(origin), and C.  <br /></td></tr>
<tr class="separator:acdf74dd717d1ff56795e5ca2ab7b0b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762f841938cca8560b03e241a2a1e943"><td class="memItemLeft" align="right" valign="top">Angle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a762f841938cca8560b03e241a2a1e943">signedInternalAngle</a> (<a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> A, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> B, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> C)</td></tr>
<tr class="memdesc:a762f841938cca8560b03e241a2a1e943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates signed angle at origin between two points. Given A, B(origin), and C.  <br /></td></tr>
<tr class="separator:a762f841938cca8560b03e241a2a1e943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112e8be18f72bf2c334919f5b9069368"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a112e8be18f72bf2c334919f5b9069368">angleFromXAxis</a> (<a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> A, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> B)</td></tr>
<tr class="memdesc:a112e8be18f72bf2c334919f5b9069368"><td class="mdescLeft">&#160;</td><td class="mdescRight">angle from x-axis and two points  <br /></td></tr>
<tr class="separator:a112e8be18f72bf2c334919f5b9069368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da6e710dca4486113e38f25b0235651"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a7da6e710dca4486113e38f25b0235651">intersect</a> (<a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> a1, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> a2, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> b1, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> b2)</td></tr>
<tr class="memdesc:a7da6e710dca4486113e38f25b0235651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that takes 4 points belonging to 2 lines and determines whether or not they intersect. Lines sharing a point are classified as intersecting.  <br /></td></tr>
<tr class="separator:a7da6e710dca4486113e38f25b0235651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6823e8ea81aba23dfa6f03935c98e45d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a6823e8ea81aba23dfa6f03935c98e45d">onSegment</a> (<a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> p, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> q, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> r)</td></tr>
<tr class="memdesc:a6823e8ea81aba23dfa6f03935c98e45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if point q lies on line segment pr. Helper function for intersect.  <br /></td></tr>
<tr class="separator:a6823e8ea81aba23dfa6f03935c98e45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c590c1f15b7c569e0a999e070957143"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a6c590c1f15b7c569e0a999e070957143">orientation</a> (<a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> A, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> B, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> C)</td></tr>
<tr class="memdesc:a6c590c1f15b7c569e0a999e070957143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the orientation of point C with respect to the line AB from the perspective of being located at A and looking toward B.  <br /></td></tr>
<tr class="separator:a6c590c1f15b7c569e0a999e070957143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae61f0df58a64c2856aabf96107acff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#acae61f0df58a64c2856aabf96107acff">lineIntersection</a> (<a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> A, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> B, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> C, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> D)</td></tr>
<tr class="memdesc:acae61f0df58a64c2856aabf96107acff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates intersection point for two, infinite lines defined by points A,B and C,D respectively Function assumes lines have been previously tested for collinearity/parallel cases. It will return (0, 0) for those cases. Unlike intersect function above, this intersection is for lines, not line segments.  <br /></td></tr>
<tr class="separator:acae61f0df58a64c2856aabf96107acff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad865aa4dc8103ca03804c3aec6ddd800"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#ad865aa4dc8103ca03804c3aec6ddd800">linePlaneIntersection</a> (<a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> line_pt, QVector3D line_direction, <a class="el" href="class_o_r_n_l_1_1_plane.html">Plane</a> plane)</td></tr>
<tr class="memdesc:ad865aa4dc8103ca03804c3aec6ddd800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the point of intersection between an infinite line and an infinite plane. Assumes that the line is not parallel to the plane (would be no intersection) and that the line is not contained within the plane (intersection would be entire line)  <br /></td></tr>
<tr class="separator:ad865aa4dc8103ca03804c3aec6ddd800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac181470d1ddf82f1f979f157c6d7b6d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#ac181470d1ddf82f1f979f157c6d7b6d4">nearCollinear</a> (<a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> A, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> B, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> C, Angle threshold)</td></tr>
<tr class="memdesc:ac181470d1ddf82f1f979f157c6d7b6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two line segments which share a point (B) are near collinear Uses law of cosines.  <br /></td></tr>
<tr class="separator:ac181470d1ddf82f1f979f157c6d7b6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30bf0357a64f32119a0b2b151947a9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#ae30bf0357a64f32119a0b2b151947a9e">slopesNearCollinear</a> (<a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> pt1, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> pt2, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> pt3, Distance distSqrd)</td></tr>
<tr class="memdesc:ae30bf0357a64f32119a0b2b151947a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two line segments which share a point (pt2) are near collinear Uses distance threshold.  <br /></td></tr>
<tr class="separator:ae30bf0357a64f32119a0b2b151947a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a31f72058baf6191afec2f3edc07f27"><td class="memItemLeft" align="right" valign="top">Distance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a8a31f72058baf6191afec2f3edc07f27">distanceFromLineSqrd</a> (<a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> pt, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> ln1, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> ln2)</td></tr>
<tr class="memdesc:a8a31f72058baf6191afec2f3edc07f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance squared of a point (pt) from a line formed by points (ln1) &amp; (ln2) Helper function for slopesNearCollinear.  <br /></td></tr>
<tr class="separator:a8a31f72058baf6191afec2f3edc07f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf258056db497dae694ce32bc8c0d586"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#adf258056db497dae694ce32bc8c0d586">distanceFromLineSegSqrd</a> (<a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> pt, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> ln1, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> ln2)</td></tr>
<tr class="memdesc:adf258056db497dae694ce32bc8c0d586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance squared of a point (pt) from a line segment formed by the points (ln1) &amp; (ln2) Helper function for poleOfInaccessibility.  <br /></td></tr>
<tr class="separator:adf258056db497dae694ce32bc8c0d586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2efecc844fc9408de054614000412c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a3d2efecc844fc9408de054614000412c">pointsAreClose</a> (<a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> pt1, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> pt2, Distance distSqrd)</td></tr>
<tr class="memdesc:a3d2efecc844fc9408de054614000412c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two points are close to one another based on distance threshold.  <br /></td></tr>
<tr class="separator:a3d2efecc844fc9408de054614000412c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8d410bcacab7d21b4482d19d38ef21"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#abb8d410bcacab7d21b4482d19d38ef21">cantorPair</a> (uint32_t a, uint32_t b)</td></tr>
<tr class="memdesc:abb8d410bcacab7d21b4482d19d38ef21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that maps two intergers to a unique result.  <br /></td></tr>
<tr class="separator:abb8d410bcacab7d21b4482d19d38ef21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782cdc3b3b3f0050040f8e2a3159bf97"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; float, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a782cdc3b3b3f0050040f8e2a3159bf97">findClosestPointOnSegment</a> (<a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> a, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> b, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> p)</td></tr>
<tr class="separator:a782cdc3b3b3f0050040f8e2a3159bf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871139abc44c1021e5459a39fead7554"><td class="memItemLeft" align="right" valign="top">QVector&lt; <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a871139abc44c1021e5459a39fead7554">chamferCorner</a> (const <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> &amp;A, const <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> &amp;B, const <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> &amp;C, Distance chamferDistance)</td></tr>
<tr class="memdesc:a871139abc44c1021e5459a39fead7554"><td class="mdescLeft">&#160;</td><td class="mdescRight">chamferCorner  <br /></td></tr>
<tr class="separator:a871139abc44c1021e5459a39fead7554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6b6d9d4a15916e006df3754261ca8c"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#aff6b6d9d4a15916e006df3754261ca8c">formattedTimeSpan</a> (Time seconds)</td></tr>
<tr class="memdesc:aff6b6d9d4a15916e006df3754261ca8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format time span to x hr y min z sec.  <br /></td></tr>
<tr class="separator:aff6b6d9d4a15916e006df3754261ca8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef63e20bdbf8eefba39cf50f9ff3e88b"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#aef63e20bdbf8eefba39cf50f9ff3e88b">formattedTimeSpan</a> (double seconds)</td></tr>
<tr class="memdesc:aef63e20bdbf8eefba39cf50f9ff3e88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format time span in seconds to x hr y min z sec.  <br /></td></tr>
<tr class="separator:aef63e20bdbf8eefba39cf50f9ff3e88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d20ce90291e99e35b81c427904f858"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#aa7d20ce90291e99e35b81c427904f858">formattedTimeSpanHHMMSS</a> (double seconds)</td></tr>
<tr class="memdesc:aa7d20ce90291e99e35b81c427904f858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format time span in seconds to HH:MM:SS.  <br /></td></tr>
<tr class="separator:aa7d20ce90291e99e35b81c427904f858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aadba2dd887196525ada300cf5e19dc"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a9aadba2dd887196525ada300cf5e19dc">formattedTimeSpanHHMMSS</a> (Time time)</td></tr>
<tr class="memdesc:a9aadba2dd887196525ada300cf5e19dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format time span to HH:MM:SS.  <br /></td></tr>
<tr class="separator:a9aadba2dd887196525ada300cf5e19dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5cc1a32ea0ad0444edd1374a980211"><td class="memItemLeft" align="right" valign="top">QQuaternion&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a8b5cc1a32ea0ad0444edd1374a980211">CreateQuaternion</a> (double x, double y, double z, <a class="el" href="namespace_o_r_n_l.html#abfbf0ab2867dd4d5b1796e6d0c7b8c55">QuaternionOrder</a> order=<a class="el" href="namespace_o_r_n_l.html#abfbf0ab2867dd4d5b1796e6d0c7b8c55a938575f030708c3bff7b29d98e5e8b17">QuaternionOrder::kXYZ</a>)</td></tr>
<tr class="memdesc:a8b5cc1a32ea0ad0444edd1374a980211"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates quaternion from 3 angles  <br /></td></tr>
<tr class="separator:a8b5cc1a32ea0ad0444edd1374a980211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c44b572fb1b17b47c50b4ea2a4bc54"><td class="memItemLeft" align="right" valign="top">QQuaternion&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a36c44b572fb1b17b47c50b4ea2a4bc54">CreateQuaternion</a> (Angle x, Angle y, Angle z, <a class="el" href="namespace_o_r_n_l.html#abfbf0ab2867dd4d5b1796e6d0c7b8c55">QuaternionOrder</a> order=<a class="el" href="namespace_o_r_n_l.html#abfbf0ab2867dd4d5b1796e6d0c7b8c55a938575f030708c3bff7b29d98e5e8b17">QuaternionOrder::kXYZ</a>)</td></tr>
<tr class="memdesc:a36c44b572fb1b17b47c50b4ea2a4bc54"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates quaternion from 3 angles  <br /></td></tr>
<tr class="separator:a36c44b572fb1b17b47c50b4ea2a4bc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3182bba69c4b8adc0040140ba402ec14"><td class="memItemLeft" align="right" valign="top">QQuaternion&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a3182bba69c4b8adc0040140ba402ec14">CreateQuaternion</a> (QVector3D vector_start, QVector3D vector_end)</td></tr>
<tr class="memdesc:a3182bba69c4b8adc0040140ba402ec14"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates quaternion dscribing the shortest rotation between 2 vectors  <br /></td></tr>
<tr class="separator:a3182bba69c4b8adc0040140ba402ec14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1ac020bd7ffc042c9f14f9dadf353f"><td class="memItemLeft" align="right" valign="top">QQuaternion&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a2c1ac020bd7ffc042c9f14f9dadf353f">AxisAngleToQuat</a> (QVector3D axis, double angle)</td></tr>
<tr class="memdesc:a2c1ac020bd7ffc042c9f14f9dadf353f"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates quaternion from 1 angle and Axis  <br /></td></tr>
<tr class="separator:a2c1ac020bd7ffc042c9f14f9dadf353f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26a6dd9f526e33201755538e0cb1f50"><td class="memItemLeft" align="right" valign="top">QQuaternion&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#ad26a6dd9f526e33201755538e0cb1f50">QuatMult</a> (QQuaternion qa, QQuaternion qb)</td></tr>
<tr class="memdesc:ad26a6dd9f526e33201755538e0cb1f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplies 2 quaternions  <br /></td></tr>
<tr class="separator:ad26a6dd9f526e33201755538e0cb1f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85079084510fcf4d6a07f099dca52666"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a85079084510fcf4d6a07f099dca52666">EulerAngles</a> (QQuaternion q, double *pitch, double *roll, double *yaw)</td></tr>
<tr class="separator:a85079084510fcf4d6a07f099dca52666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64734ec04a5a10758f7fec948f8ad7ee"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a64734ec04a5a10758f7fec948f8ad7ee">findBinomialCoefficients</a> (int n, int k)</td></tr>
<tr class="memdesc:a64734ec04a5a10758f7fec948f8ad7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the binomial coefficients for n and k according to the binomial theorem  <br /></td></tr>
<tr class="separator:a64734ec04a5a10758f7fec948f8ad7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02229ed5cfeb53b5f5702535d9dd8da"><td class="memItemLeft" align="right" valign="top">QMatrix4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#aa02229ed5cfeb53b5f5702535d9dd8da">composeTransformMatrix</a> (QVector3D t, QQuaternion r, QVector3D s)</td></tr>
<tr class="memdesc:aa02229ed5cfeb53b5f5702535d9dd8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transform matrix from the components.  <br /></td></tr>
<tr class="separator:aa02229ed5cfeb53b5f5702535d9dd8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df4287269bd25e11d2e8cfe90700f2f"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; QVector3D, QQuaternion, QVector3D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a5df4287269bd25e11d2e8cfe90700f2f">decomposeTransformMatrix</a> (QMatrix4x4 mtrx)</td></tr>
<tr class="memdesc:a5df4287269bd25e11d2e8cfe90700f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a 4x4 matrix, decomposes it into translation, rotation, and scale.  <br /></td></tr>
<tr class="separator:a5df4287269bd25e11d2e8cfe90700f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b77dc1d59b94140a763a8fbcb0b6e40"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a1b77dc1d59b94140a763a8fbcb0b6e40">snap</a> (double val, double interval)</td></tr>
<tr class="memdesc:a1b77dc1d59b94140a763a8fbcb0b6e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snaps the passed value to the nearest interval value.  <br /></td></tr>
<tr class="separator:a1b77dc1d59b94140a763a8fbcb0b6e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc4a32e5d21b4fbd3841ad1487e2557"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a4dc4a32e5d21b4fbd3841ad1487e2557">clamp</a> (double min, double val, double <a class="el" href="namespace_o_r_n_l.html#a801e94c56d4c5894dde046343b5a0402">max</a>)</td></tr>
<tr class="memdesc:a4dc4a32e5d21b4fbd3841ad1487e2557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple function to bring value between min and max.  <br /></td></tr>
<tr class="separator:a4dc4a32e5d21b4fbd3841ad1487e2557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89672d4194883a55711901bad7838d14"><td class="memItemLeft" align="right" valign="top">QVector3D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a89672d4194883a55711901bad7838d14">sphericalToCartesian</a> (float rho, float theta, float phi)</td></tr>
<tr class="memdesc:a89672d4194883a55711901bad7838d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a set of spherical coordinates to cartesian coordinates. All angles are degrees.  <br /></td></tr>
<tr class="separator:a89672d4194883a55711901bad7838d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Commonly used math functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a112e8be18f72bf2c334919f5b9069368" name="a112e8be18f72bf2c334919f5b9069368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112e8be18f72bf2c334919f5b9069368">&#9670;&#160;</a></span>angleFromXAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ORNL::MathUtils::angleFromXAxis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>angle from x-axis and two points </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first point </td></tr>
    <tr><td class="paramname">B</td><td>second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle </dd></dl>

</div>
</div>
<a id="a2c1ac020bd7ffc042c9f14f9dadf353f" name="a2c1ac020bd7ffc042c9f14f9dadf353f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1ac020bd7ffc042c9f14f9dadf353f">&#9670;&#160;</a></span>AxisAngleToQuat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QQuaternion ORNL::MathUtils::AxisAngleToQuat </td>
          <td>(</td>
          <td class="paramtype">QVector3D&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates quaternion from 1 angle and Axis </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>defining the axis to be rotated around </td></tr>
    <tr><td class="paramname">angle</td><td>of rotation in radians </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb8d410bcacab7d21b4482d19d38ef21" name="abb8d410bcacab7d21b4482d19d38ef21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8d410bcacab7d21b4482d19d38ef21">&#9670;&#160;</a></span>cantorPair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ORNL::MathUtils::cantorPair </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that maps two intergers to a unique result. </p>
<dl class="section note"><dt>Note</dt><dd>See: <a href="https://stackoverflow.com/questions/919612/">https://stackoverflow.com/questions/919612/</a> </dd></dl>

</div>
</div>
<a id="a736452ad174b8b24f405740d1d46bdae" name="a736452ad174b8b24f405740d1d46bdae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736452ad174b8b24f405740d1d46bdae">&#9670;&#160;</a></span>center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> ORNL::MathUtils::center </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> &gt;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the center of a group of points. </p>

</div>
</div>
<a id="a871139abc44c1021e5459a39fead7554" name="a871139abc44c1021e5459a39fead7554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871139abc44c1021e5459a39fead7554">&#9670;&#160;</a></span>chamferCorner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QVector&lt; <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> &gt; ORNL::MathUtils::chamferCorner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Distance&#160;</td>
          <td class="paramname"><em>chamferDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>chamferCorner </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- exterior point of the corner to be chamfered </td></tr>
    <tr><td class="paramname">B</td><td>- interior point of the corner to be chamfered </td></tr>
    <tr><td class="paramname">C</td><td>- exterior point of the corner to be chamfered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corner ABC chamfered returned as a vector of Points {B1,B2} </dd></dl>

</div>
</div>
<a id="a4dc4a32e5d21b4fbd3841ad1487e2557" name="a4dc4a32e5d21b4fbd3841ad1487e2557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc4a32e5d21b4fbd3841ad1487e2557">&#9670;&#160;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ORNL::MathUtils::clamp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple function to bring value between min and max. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>Min value </td></tr>
    <tr><td class="paramname">val</td><td>Value to check </td></tr>
    <tr><td class="paramname">max</td><td>Max value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value if between min and max, min or max if outside of this range. </dd></dl>

</div>
</div>
<a id="aa02229ed5cfeb53b5f5702535d9dd8da" name="aa02229ed5cfeb53b5f5702535d9dd8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02229ed5cfeb53b5f5702535d9dd8da">&#9670;&#160;</a></span>composeTransformMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QMatrix4x4 ORNL::MathUtils::composeTransformMatrix </td>
          <td>(</td>
          <td class="paramtype">QVector3D&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QQuaternion&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector3D&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transform matrix from the components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The translation vector. </td></tr>
    <tr><td class="paramname">r</td><td>The rotation vector. </td></tr>
    <tr><td class="paramname">s</td><td>The scale vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transform matrix. </dd></dl>

</div>
</div>
<a id="a36c44b572fb1b17b47c50b4ea2a4bc54" name="a36c44b572fb1b17b47c50b4ea2a4bc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c44b572fb1b17b47c50b4ea2a4bc54">&#9670;&#160;</a></span>CreateQuaternion() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QQuaternion ORNL::MathUtils::CreateQuaternion </td>
          <td>(</td>
          <td class="paramtype">Angle&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Angle&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Angle&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_r_n_l.html#abfbf0ab2867dd4d5b1796e6d0c7b8c55">QuaternionOrder</a>&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespace_o_r_n_l.html#abfbf0ab2867dd4d5b1796e6d0c7b8c55a938575f030708c3bff7b29d98e5e8b17">QuaternionOrder::kXYZ</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates quaternion from 3 angles </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>of rotation around x-axis </td></tr>
    <tr><td class="paramname">angle</td><td>of rotation around y-axis </td></tr>
    <tr><td class="paramname">angle</td><td>of rotation around z-axis </td></tr>
    <tr><td class="paramname">order</td><td>Order of axis application (XYZ by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b5cc1a32ea0ad0444edd1374a980211" name="a8b5cc1a32ea0ad0444edd1374a980211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5cc1a32ea0ad0444edd1374a980211">&#9670;&#160;</a></span>CreateQuaternion() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QQuaternion ORNL::MathUtils::CreateQuaternion </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_o_r_n_l.html#abfbf0ab2867dd4d5b1796e6d0c7b8c55">QuaternionOrder</a>&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespace_o_r_n_l.html#abfbf0ab2867dd4d5b1796e6d0c7b8c55a938575f030708c3bff7b29d98e5e8b17">QuaternionOrder::kXYZ</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates quaternion from 3 angles </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>of rotation around x-axis in degrees </td></tr>
    <tr><td class="paramname">angle</td><td>of rotation around y-axis in degrees </td></tr>
    <tr><td class="paramname">angle</td><td>of rotation around z-axis in degrees </td></tr>
    <tr><td class="paramname">order</td><td>Order of axis application (XYZ by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3182bba69c4b8adc0040140ba402ec14" name="a3182bba69c4b8adc0040140ba402ec14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3182bba69c4b8adc0040140ba402ec14">&#9670;&#160;</a></span>CreateQuaternion() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QQuaternion ORNL::MathUtils::CreateQuaternion </td>
          <td>(</td>
          <td class="paramtype">QVector3D&#160;</td>
          <td class="paramname"><em>vector_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector3D&#160;</td>
          <td class="paramname"><em>vector_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates quaternion dscribing the shortest rotation between 2 vectors </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>1, beginning of rotation </td></tr>
    <tr><td class="paramname">vector</td><td>2, end of rotation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5df4287269bd25e11d2e8cfe90700f2f" name="a5df4287269bd25e11d2e8cfe90700f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df4287269bd25e11d2e8cfe90700f2f">&#9670;&#160;</a></span>decomposeTransformMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; QVector3D, QQuaternion, QVector3D &gt; ORNL::MathUtils::decomposeTransformMatrix </td>
          <td>(</td>
          <td class="paramtype">QMatrix4x4&#160;</td>
          <td class="paramname"><em>mtrx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a 4x4 matrix, decomposes it into translation, rotation, and scale. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtrx</td><td>The matrix to decompose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Translation, rotation, and scale - in that order. </dd></dl>

</div>
</div>
<a id="adf258056db497dae694ce32bc8c0d586" name="adf258056db497dae694ce32bc8c0d586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf258056db497dae694ce32bc8c0d586">&#9670;&#160;</a></span>distanceFromLineSegSqrd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ORNL::MathUtils::distanceFromLineSegSqrd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>ln1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>ln2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the distance squared of a point (pt) from a line segment formed by the points (ln1) &amp; (ln2) Helper function for poleOfInaccessibility. </p>

</div>
</div>
<a id="a8a31f72058baf6191afec2f3edc07f27" name="a8a31f72058baf6191afec2f3edc07f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a31f72058baf6191afec2f3edc07f27">&#9670;&#160;</a></span>distanceFromLineSqrd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Distance ORNL::MathUtils::distanceFromLineSqrd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>ln1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>ln2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the distance squared of a point (pt) from a line formed by points (ln1) &amp; (ln2) Helper function for slopesNearCollinear. </p>

</div>
</div>
<a id="ab741e2fe56626b447e355869496fd9df" name="ab741e2fe56626b447e355869496fd9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab741e2fe56626b447e355869496fd9df">&#9670;&#160;</a></span>equals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ORNL::MathUtils::equals </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a function that compares two doubles </p>
<dl class="section note"><dt>Note</dt><dd>Much better than a == b which can result in them being deemed unequal, even when they are logically equivalent </dd></dl>

</div>
</div>
<a id="aa24e9236be072bf16a9846d3f6156583" name="aa24e9236be072bf16a9846d3f6156583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24e9236be072bf16a9846d3f6156583">&#9670;&#160;</a></span>equals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ORNL::MathUtils::equals </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85079084510fcf4d6a07f099dca52666" name="a85079084510fcf4d6a07f099dca52666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85079084510fcf4d6a07f099dca52666">&#9670;&#160;</a></span>EulerAngles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORNL::MathUtils::EulerAngles </td>
          <td>(</td>
          <td class="paramtype">QQuaternion&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>roll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>yaw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64734ec04a5a10758f7fec948f8ad7ee" name="a64734ec04a5a10758f7fec948f8ad7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64734ec04a5a10758f7fec948f8ad7ee">&#9670;&#160;</a></span>findBinomialCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ORNL::MathUtils::findBinomialCoefficients </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the binomial coefficients for n and k according to the binomial theorem </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>integer </td></tr>
    <tr><td class="paramname">second</td><td>integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a782cdc3b3b3f0050040f8e2a3159bf97" name="a782cdc3b3b3f0050040f8e2a3159bf97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782cdc3b3b3f0050040f8e2a3159bf97">&#9670;&#160;</a></span>findClosestPointOnSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; float, <a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> &gt; ORNL::MathUtils::findClosestPointOnSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef63e20bdbf8eefba39cf50f9ff3e88b" name="aef63e20bdbf8eefba39cf50f9ff3e88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef63e20bdbf8eefba39cf50f9ff3e88b">&#9670;&#160;</a></span>formattedTimeSpan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString ORNL::MathUtils::formattedTimeSpan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format time span in seconds to x hr y min z sec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>in double </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff6b6d9d4a15916e006df3754261ca8c" name="aff6b6d9d4a15916e006df3754261ca8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6b6d9d4a15916e006df3754261ca8c">&#9670;&#160;</a></span>formattedTimeSpan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString ORNL::MathUtils::formattedTimeSpan </td>
          <td>(</td>
          <td class="paramtype">Time&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format time span to x hr y min z sec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>in Time unit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7d20ce90291e99e35b81c427904f858" name="aa7d20ce90291e99e35b81c427904f858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d20ce90291e99e35b81c427904f858">&#9670;&#160;</a></span>formattedTimeSpanHHMMSS() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString ORNL::MathUtils::formattedTimeSpanHHMMSS </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format time span in seconds to HH:MM:SS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>in double </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9aadba2dd887196525ada300cf5e19dc" name="a9aadba2dd887196525ada300cf5e19dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aadba2dd887196525ada300cf5e19dc">&#9670;&#160;</a></span>formattedTimeSpanHHMMSS() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString ORNL::MathUtils::formattedTimeSpanHHMMSS </td>
          <td>(</td>
          <td class="paramtype">Time&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format time span to HH:MM:SS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>in Time unit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45ed4d00b49500f2a31249e10e4e1825" name="a45ed4d00b49500f2a31249e10e4e1825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ed4d00b49500f2a31249e10e4e1825">&#9670;&#160;</a></span>glEquals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ORNL::MathUtils::glEquals </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two doubles but with a higher epsilon for. </p>
<p>Compares two doubles but with a higher epsilon for comparison. Useful for OpenGL comparisons.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value </td></tr>
    <tr><td class="paramname">b</td><td>Value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the doubles are considered 'equal'. </dd></dl>

</div>
</div>
<a id="acdf74dd717d1ff56795e5ca2ab7b0b50" name="acdf74dd717d1ff56795e5ca2ab7b0b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf74dd717d1ff56795e5ca2ab7b0b50">&#9670;&#160;</a></span>internalAngle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Angle ORNL::MathUtils::internalAngle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates angle at origin between two points. Given A, B(origin), and C. </p>
<dl class="section note"><dt>Note</dt><dd>this is unsigned, </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html#a762f841938cca8560b03e241a2a1e943" title="Calculates signed angle at origin between two points. Given A, B(origin), and C.">signedInternalAngle</a> for signed calculation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first point </td></tr>
    <tr><td class="paramname">B</td><td>second point (origin) </td></tr>
    <tr><td class="paramname">C</td><td>third point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7da6e710dca4486113e38f25b0235651" name="a7da6e710dca4486113e38f25b0235651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da6e710dca4486113e38f25b0235651">&#9670;&#160;</a></span>intersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ORNL::MathUtils::intersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>b2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that takes 4 points belonging to 2 lines and determines whether or not they intersect. Lines sharing a point are classified as intersecting. </p>

</div>
</div>
<a id="acae61f0df58a64c2856aabf96107acff" name="acae61f0df58a64c2856aabf96107acff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae61f0df58a64c2856aabf96107acff">&#9670;&#160;</a></span>lineIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> ORNL::MathUtils::lineIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates intersection point for two, infinite lines defined by points A,B and C,D respectively Function assumes lines have been previously tested for collinearity/parallel cases. It will return (0, 0) for those cases. Unlike intersect function above, this intersection is for lines, not line segments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first point for line 1 </td></tr>
    <tr><td class="paramname">B</td><td>second point for line 1 </td></tr>
    <tr><td class="paramname">C</td><td>first point for line 2 </td></tr>
    <tr><td class="paramname">D</td><td>second point for line 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>point of intersection </dd></dl>

</div>
</div>
<a id="ad865aa4dc8103ca03804c3aec6ddd800" name="ad865aa4dc8103ca03804c3aec6ddd800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad865aa4dc8103ca03804c3aec6ddd800">&#9670;&#160;</a></span>linePlaneIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a> ORNL::MathUtils::linePlaneIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>line_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector3D&#160;</td>
          <td class="paramname"><em>line_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_plane.html">Plane</a>&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the point of intersection between an infinite line and an infinite plane. Assumes that the line is not parallel to the plane (would be no intersection) and that the line is not contained within the plane (intersection would be entire line) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line_pt</td><td>point to define the line </td></tr>
    <tr><td class="paramname">line_direction</td><td>vector to define the line </td></tr>
    <tr><td class="paramname">plane</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>point of intersection </dd></dl>

</div>
</div>
<a id="ac181470d1ddf82f1f979f157c6d7b6d4" name="ac181470d1ddf82f1f979f157c6d7b6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac181470d1ddf82f1f979f157c6d7b6d4">&#9670;&#160;</a></span>nearCollinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ORNL::MathUtils::nearCollinear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Angle&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if two line segments which share a point (B) are near collinear Uses law of cosines. </p>

</div>
</div>
<a id="a70e07cebd1635fd5676cccbdafeb449b" name="a70e07cebd1635fd5676cccbdafeb449b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e07cebd1635fd5676cccbdafeb449b">&#9670;&#160;</a></span>notEquals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ORNL::MathUtils::notEquals </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a function that compares two doubles </p>
<dl class="section note"><dt>Note</dt><dd>Much better than a != b which can result in them being deemed unequal, even when they are logically equivalent </dd></dl>

</div>
</div>
<a id="a6823e8ea81aba23dfa6f03935c98e45d" name="a6823e8ea81aba23dfa6f03935c98e45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6823e8ea81aba23dfa6f03935c98e45d">&#9670;&#160;</a></span>onSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ORNL::MathUtils::onSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if point q lies on line segment pr. Helper function for intersect. </p>

</div>
</div>
<a id="a6c590c1f15b7c569e0a999e070957143" name="a6c590c1f15b7c569e0a999e070957143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c590c1f15b7c569e0a999e070957143">&#9670;&#160;</a></span>orientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short ORNL::MathUtils::orientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the orientation of point C with respect to the line AB from the perspective of being located at A and looking toward B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>start point of line segment AB </td></tr>
    <tr><td class="paramname">B</td><td>end point of line segment AB </td></tr>
    <tr><td class="paramname">C</td><td>point for which the orientation is being determined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The orientation of C with respect to the line AB 0 = C is colinear to line AB -1 = C lies to the left of the line AB from the perspective outlined above (ABC is ccw) 1 = C lies to the right of the line AB from the perspective outlined above (ABC is cw) </dd></dl>
<p><a class="el" href="class_o_r_n_l_1_1_point.html" title="Point class that converts to variable other 2d objects.">Point</a> C is colinear to line AB</p>
<p><a class="el" href="class_o_r_n_l_1_1_point.html" title="Point class that converts to variable other 2d objects.">Point</a> C lies to the left of line AB -&gt; orientation of ABC is ccw</p>
<p><a class="el" href="class_o_r_n_l_1_1_point.html" title="Point class that converts to variable other 2d objects.">Point</a> C lies to the right of line AB -&gt; orientation of ABC is cw</p>
<p><a class="el" href="class_o_r_n_l_1_1_point.html" title="Point class that converts to variable other 2d objects.">Point</a> C is colinear to line AB</p>
<p><a class="el" href="class_o_r_n_l_1_1_point.html" title="Point class that converts to variable other 2d objects.">Point</a> C lies to the left of line AB -&gt; orientation of ABC is ccw</p>
<p><a class="el" href="class_o_r_n_l_1_1_point.html" title="Point class that converts to variable other 2d objects.">Point</a> C lies to the right of line AB -&gt; orientation of ABC is cw</p>

</div>
</div>
<a id="a3d2efecc844fc9408de054614000412c" name="a3d2efecc844fc9408de054614000412c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2efecc844fc9408de054614000412c">&#9670;&#160;</a></span>pointsAreClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ORNL::MathUtils::pointsAreClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Distance&#160;</td>
          <td class="paramname"><em>distSqrd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if two points are close to one another based on distance threshold. </p>

</div>
</div>
<a id="ad26a6dd9f526e33201755538e0cb1f50" name="ad26a6dd9f526e33201755538e0cb1f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26a6dd9f526e33201755538e0cb1f50">&#9670;&#160;</a></span>QuatMult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QQuaternion ORNL::MathUtils::QuatMult </td>
          <td>(</td>
          <td class="paramtype">QQuaternion&#160;</td>
          <td class="paramname"><em>qa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QQuaternion&#160;</td>
          <td class="paramname"><em>qb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiplies 2 quaternions </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quaternion</td><td>to be multiplicand </td></tr>
    <tr><td class="paramname">quanternion</td><td>to be multiplier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a762f841938cca8560b03e241a2a1e943" name="a762f841938cca8560b03e241a2a1e943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762f841938cca8560b03e241a2a1e943">&#9670;&#160;</a></span>signedInternalAngle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Angle ORNL::MathUtils::signedInternalAngle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates signed angle at origin between two points. Given A, B(origin), and C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first point </td></tr>
    <tr><td class="paramname">B</td><td>second point (origin) </td></tr>
    <tr><td class="paramname">C</td><td>third point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae30bf0357a64f32119a0b2b151947a9e" name="ae30bf0357a64f32119a0b2b151947a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30bf0357a64f32119a0b2b151947a9e">&#9670;&#160;</a></span>slopesNearCollinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ORNL::MathUtils::slopesNearCollinear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_n_l_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Distance&#160;</td>
          <td class="paramname"><em>distSqrd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if two line segments which share a point (pt2) are near collinear Uses distance threshold. </p>

</div>
</div>
<a id="a1b77dc1d59b94140a763a8fbcb0b6e40" name="a1b77dc1d59b94140a763a8fbcb0b6e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b77dc1d59b94140a763a8fbcb0b6e40">&#9670;&#160;</a></span>snap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ORNL::MathUtils::snap </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Snaps the passed value to the nearest interval value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to snap </td></tr>
    <tr><td class="paramname">interval</td><td>The interval to snap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The snapped value. </dd></dl>

</div>
</div>
<a id="a89672d4194883a55711901bad7838d14" name="a89672d4194883a55711901bad7838d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89672d4194883a55711901bad7838d14">&#9670;&#160;</a></span>sphericalToCartesian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QVector3D ORNL::MathUtils::sphericalToCartesian </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a set of spherical coordinates to cartesian coordinates. All angles are degrees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rho</td><td>Radial distance. </td></tr>
    <tr><td class="paramname">theta</td><td>Azmuthal angle (angle from x axis). </td></tr>
    <tr><td class="paramname">phi</td><td>Polar angle (angle from z axis). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cartesian coordinates. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_o_r_n_l.html">ORNL</a></li><li class="navelem"><a class="el" href="namespace_o_r_n_l_1_1_math_utils.html">MathUtils</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
